diff --git a/documentation/conf.py b/documentation/conf.py
index 5d49cf9..7b36e27 100644
--- a/documentation/conf.py
+++ b/documentation/conf.py
@@ -340,8 +340,8 @@ def skip_numpy_not_numerix(app, what, name, obj, skip, options):
     import types
     if ((type(obj) in [types.FunctionType, 
                        types.BuiltinFunctionType,
-                       types.ClassType, 
-                       types.TypeType]) 
+                       type, 
+                       type]) 
         and not (obj.__module__.startswith("fipy")
                  or obj.__module__.startswith("package"))):
             skip = True
diff --git a/documentation/sphinxext/docscrape.py b/documentation/sphinxext/docscrape.py
index f374b3d..8d32758 100644
--- a/documentation/sphinxext/docscrape.py
+++ b/documentation/sphinxext/docscrape.py
@@ -1,12 +1,16 @@
 """Extract reference documentation from the NumPy source tree.
 
 """
+from __future__ import print_function
+from future import standard_library
+standard_library.install_aliases()
+from builtins import object
 
 import inspect
 import textwrap
 import re
 import pydoc
-from StringIO import StringIO
+from io import StringIO
 from warnings import warn
 4
 class Reader(object):
@@ -113,7 +117,7 @@ class NumpyDocString(object):
         return self._parsed_data[key]
 
     def __setitem__(self,key,val):
-        if not self._parsed_data.has_key(key):
+        if key not in self._parsed_data:
             warn("Unknown section %s" % key)
         else:
             self._parsed_data[key] = val
@@ -369,7 +373,7 @@ class NumpyDocString(object):
         idx = self['index']
         out = []
         out += ['.. index:: %s' % idx.get('default','')]
-        for section, references in idx.iteritems():
+        for section, references in idx.items():
             if section == 'default':
                 continue
             out += ['   :%s: %s' % (section, ', '.join(references))]
@@ -413,10 +417,10 @@ class FunctionDoc(NumpyDocString):
             doc = inspect.getdoc(func) or ''
         try:
             NumpyDocString.__init__(self, doc)
-        except ValueError, e:
-            print '*'*78
-            print "ERROR: '%s' while parsing `%s`" % (e, self._f)
-            print '*'*78
+        except ValueError as e:
+            print('*'*78)
+            print("ERROR: '%s' while parsing `%s`" % (e, self._f))
+            print('*'*78)
             #print "Docstring follows:"
             #print doclines
             #print '='*78
@@ -429,7 +433,7 @@ class FunctionDoc(NumpyDocString):
                 argspec = inspect.formatargspec(*argspec)
                 argspec = argspec.replace('*','\*')
                 signature = '%s%s' % (func_name, argspec)
-            except TypeError, e:
+            except TypeError as e:
                 signature = '%s()' % func_name
             self['Signature'] = signature
 
@@ -451,8 +455,8 @@ class FunctionDoc(NumpyDocString):
                  'meth': 'method'}
 
         if self._role:
-            if not roles.has_key(self._role):
-                print "Warning: invalid role %s" % self._role
+            if self._role not in roles:
+                print("Warning: invalid role %s" % self._role)
             out += '.. %s:: %s\n    \n\n' % (roles.get(self._role,''),
                                              func_name)
 
diff --git a/documentation/sphinxext/docscrape_sphinx.py b/documentation/sphinxext/docscrape_sphinx.py
index 77ed271..ed05933 100644
--- a/documentation/sphinxext/docscrape_sphinx.py
+++ b/documentation/sphinxext/docscrape_sphinx.py
@@ -1,5 +1,6 @@
+from __future__ import absolute_import
 import re, inspect, textwrap, pydoc
-from docscrape import NumpyDocString, FunctionDoc, ClassDoc
+from .docscrape import NumpyDocString, FunctionDoc, ClassDoc
 
 class SphinxDocString(NumpyDocString):
     # string conversion routines
@@ -73,7 +74,7 @@ class SphinxDocString(NumpyDocString):
             return out
 
         out += ['.. index:: %s' % idx.get('default','')]
-        for section, references in idx.iteritems():
+        for section, references in idx.items():
             if section == 'default':
                 continue
             elif section == 'refguide':
diff --git a/documentation/sphinxext/example.py b/documentation/sphinxext/example.py
index 3ab842f..7d78f63 100644
--- a/documentation/sphinxext/example.py
+++ b/documentation/sphinxext/example.py
@@ -1,3 +1,4 @@
+from __future__ import print_function
 import os.path
 import posixpath
 
@@ -51,12 +52,12 @@ class FiPyExample(Directive):
                 error_handler=(self.state.document.settings.\
                                input_encoding_error_handler),
                 handle_io_errors=None)
-        except IOError, error:
+        except IOError as error:
             raise self.severe('Problems with "%s" directive path:\n%s: %s.'
                               % (self.name, error.__class__.__name__, error))
         try:
             include_text = include_file.read()
-        except UnicodeError, error:
+        except UnicodeError as error:
             raise self.severe(
                 'Problem with "%s" directive:\n%s: %s'
                 % (self.name, error.__class__.__name__, error))
@@ -95,7 +96,7 @@ class FiPyExample(Directive):
 def exampletree_directive(name, arguments, options, content, lineno,
                           content_offset, block_text, state, state_machine):
                               
-    print "exampletree_directive"
+    print("exampletree_directive")
     
     env = state.document.settings.env
     suffix = env.config.source_suffix
@@ -143,14 +144,14 @@ def exampletree_directive(name, arguments, options, content, lineno,
                     line=lineno))
     subnode['includefiles'] = includefiles
     
-    print "exampletree:", subnode
+    print("exampletree:", subnode)
 
     subnode['includetitles'] = includetitles
     subnode['maxdepth'] = options.get('maxdepth', -1)
     subnode['glob'] = glob
     ret.append(subnode)
     
-    print "exampletree:", subnode
+    print("exampletree:", subnode)
 
     return ret
     
@@ -237,15 +238,15 @@ class ExampleTree(Directive):
         return ret
 
 def process_missing_example(app, env, node, contnode):
-    print "app:", app
-    print "env:", env
-    print "node:", node
-    print "contnode:", contnode
+    print("app:", app)
+    print("env:", env)
+    print("node:", node)
+    print("contnode:", contnode)
     
     return None
     
 def doctree_read(app, doctree):
-    print "doctree:", doctree.attributes['source']
+    print("doctree:", doctree.attributes['source'])
     
 def autodoc_process_docstring(app, what, name, obj, options, lines):
     if name.startswith("examples."):
@@ -254,7 +255,7 @@ def autodoc_process_docstring(app, what, name, obj, options, lines):
         lines.insert(1, "-" * len(title))
     
 def source_read(app, docname, source):
-    print "source-read:", docname
+    print("source-read:", docname)
         
 def setup(app):
     app.add_directive('fipyexample', FiPyExample)
diff --git a/documentation/sphinxext/numpydoc.py b/documentation/sphinxext/numpydoc.py
index ff6c44c..e4e9fde 100644
--- a/documentation/sphinxext/numpydoc.py
+++ b/documentation/sphinxext/numpydoc.py
@@ -15,9 +15,12 @@ It will:
 .. [1] http://projects.scipy.org/scipy/numpy/wiki/CodingStyleGuidelines#docstring-standard
 
 """
+from __future__ import print_function
+from __future__ import absolute_import
+from builtins import str
 
 import os, re, pydoc
-from docscrape_sphinx import get_doc_object, SphinxDocString
+from .docscrape_sphinx import get_doc_object, SphinxDocString
 import inspect
 
 def mangle_docstrings(app, what, name, obj, options, lines,
@@ -49,7 +52,7 @@ def mangle_docstrings(app, what, name, obj, options, lines,
             try:
                 references.append(int(l[len('.. ['):l.index(']')]))
             except ValueError:
-                print "WARNING: invalid reference in %s docstring" % name
+                print("WARNING: invalid reference in %s docstring" % name)
 
     # Start renaming from the biggest number, otherwise we may
     # overwrite references.
@@ -104,7 +107,7 @@ def monkeypatch_sphinx_ext_autodoc():
     if sphinx.ext.autodoc.format_signature is our_format_signature:
         return
 
-    print "[numpydoc] Monkeypatching sphinx.ext.autodoc ..."
+    print("[numpydoc] Monkeypatching sphinx.ext.autodoc ...")
     _original_format_signature = sphinx.ext.autodoc.format_signature
     sphinx.ext.autodoc.format_signature = our_format_signature
 
diff --git a/documentation/sphinxext/redirecting_html.py b/documentation/sphinxext/redirecting_html.py
index a0afe57..2e659cf 100644
--- a/documentation/sphinxext/redirecting_html.py
+++ b/documentation/sphinxext/redirecting_html.py
@@ -1,5 +1,7 @@
+from future import standard_library
+standard_library.install_aliases()
 from docutils import nodes
-import urlparse
+import urllib.parse
 
 from sphinx.builders.html import StandaloneHTMLBuilder
 
@@ -14,7 +16,7 @@ class RedirectingHTMLBuilder(StandaloneHTMLBuilder):
         for node in doctree.traverse(nodes.reference):
             try:
                 uri = node['refuri']
-                uri = urlparse.urlparse(uri)
+                uri = urllib.parse.urlparse(uri)
                 if uri.scheme in ["http", "https"]:
                     if not uri.netloc.endswith("nist.gov"):
                         node['refuri'] = "/cgi-bin/redirect.py?url=" + uri.geturl()
diff --git a/documentation/tutorial/package/subpackage/base.py b/documentation/tutorial/package/subpackage/base.py
index d9af71f..5903208 100644
--- a/documentation/tutorial/package/subpackage/base.py
+++ b/documentation/tutorial/package/subpackage/base.py
@@ -48,9 +48,10 @@ in which case you refer to it by its full name of :mod:`package.subpackage.base`
     
 in which case you can refer simply to :mod:`~package.subpackage.base`.
 """
+from builtins import object
 __docformat__ = 'restructuredtext'
 
-class Base:
+class Base(object):
     """
     With very few exceptions, the name of a class will be the capitalized
     form of the module it resides in.  Depending on how you imported the
diff --git a/examples/benchmarking/benchmarker.py b/examples/benchmarking/benchmarker.py
index e4933ac..bb5fbc5 100644
--- a/examples/benchmarking/benchmarker.py
+++ b/examples/benchmarking/benchmarker.py
@@ -30,6 +30,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import str
+from past.utils import old_div
 import os
 import sys
 import re
@@ -134,18 +138,18 @@ p = Popen(("python", path) + args, stdout=PIPE)
 rsz, vsz, cpu = monitor(p)
 
 for l in p.stdout:
-    print l.rstrip()
+    print(l.rstrip())
 
-print "-" * 79
+print("-" * 79)
 
 if steps == 0:
-    print "           cpu time: %.9f s / step / cell" % cpu
-    print "max resident memory: %.2f B / cell" % float(rsz)
-    print " max virtual memory: %.2f B / cell" % float(vsz)
+    print("           cpu time: %.9f s / step / cell" % cpu)
+    print("max resident memory: %.2f B / cell" % float(rsz))
+    print(" max virtual memory: %.2f B / cell" % float(vsz))
 else:
-    print "           cpu time: %.9f s / step / cell" % ((cpu - cpu0) / steps / N**2)
-    print "max resident memory: %.2f B / cell" % (float(rsz) / N**2)
-    print " max virtual memory: %.2f B / cell" % (float(vsz) / N**2)
+    print("           cpu time: %.9f s / step / cell" % ((cpu - cpu0) / steps / N**2))
+    print("max resident memory: %.2f B / cell" % (old_div(float(rsz), N**2)))
+    print(" max virtual memory: %.2f B / cell" % (old_div(float(vsz), N**2)))
 
 os.remove(path)
 
diff --git a/examples/benchmarking/size.py b/examples/benchmarking/size.py
index 1b6b4dc..6913ce5 100644
--- a/examples/benchmarking/size.py
+++ b/examples/benchmarking/size.py
@@ -30,6 +30,7 @@
  # ###################################################################
  ##
 
+from __future__ import print_function
 import os
 import sys
 import re
@@ -49,7 +50,7 @@ benchmarker = os.path.join(os.path.dirname(__file__),
 
 args = sys.argv[1:]
 
-print "size\tcpu / (s / step / cell)\trsz / (B / cell)\tvsz / (B / cell)"
+print("size\tcpu / (s / step / cell)\trsz / (B / cell)\tvsz / (B / cell)")
 
 for size in numerix.arange(2,6.5,0.5):
     p = Popen(["python", benchmarker] + args 
@@ -69,6 +70,6 @@ for size in numerix.arange(2,6.5,0.5):
 
     cpu, rsz, vsz = monitor(p)
 
-    print "%d\t%g\t%g\t%g" % (10**size, cpu, rsz, vsz)
+    print("%d\t%g\t%g\t%g" % (10**size, cpu, rsz, vsz))
 
 
diff --git a/examples/benchmarking/steps.py b/examples/benchmarking/steps.py
index 3bc9405..aba4663 100644
--- a/examples/benchmarking/steps.py
+++ b/examples/benchmarking/steps.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import range
 #!/usr/bin/env python
 
 ## 
@@ -57,7 +59,7 @@ p = Popen(["python", benchmarker] + args
 
 cpu0, rsz0, vsz0 = monitor(p)
 
-print "step\tcpu / (s / step / cell)\trsz / (B / cell)\tvsz / (B / cell)"
+print("step\tcpu / (s / step / cell)\trsz / (B / cell)\tvsz / (B / cell)")
 
 for block in range(blocks):
     p = Popen(["python", benchmarker, 
@@ -68,6 +70,6 @@ for block in range(blocks):
 
     cpu, rsz, vsz = monitor(p)
 
-    print "%d\t%g\t%g\t%g" % (block * steps, cpu, rsz, vsz)
+    print("%d\t%g\t%g\t%g" % (block * steps, cpu, rsz, vsz))
 
 
diff --git a/examples/benchmarking/versions.py b/examples/benchmarking/versions.py
index 468f546..9a7d126 100644
--- a/examples/benchmarking/versions.py
+++ b/examples/benchmarking/versions.py
@@ -30,6 +30,7 @@
  # ###################################################################
  ##
 
+from __future__ import print_function
 import os
 import re
 import shutil
@@ -111,11 +112,11 @@ try:
                       
             cpu, rsz, vsz = monitor(p)
             
-            print entry.revision.number, cpu, rsz, vsz
+            print(entry.revision.number, cpu, rsz, vsz)
             
-        except Exception, e:
-            print entry.revision.number, e
-except Exception, e:
-    print e
+        except Exception as e:
+            print(entry.revision.number, e)
+except Exception as e:
+    print(e)
     
 shutil.rmtree(dir)
diff --git a/examples/cahnHilliard/mesh2D.py b/examples/cahnHilliard/mesh2D.py
index 73e98a6..752d181 100755
--- a/examples/cahnHilliard/mesh2D.py
+++ b/examples/cahnHilliard/mesh2D.py
@@ -140,12 +140,13 @@ True
    :alt: evolution of Cahn-Hilliard phase separation at t = 30, 100 and 1000
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/cahnHilliard/mesh2DCoupled.py b/examples/cahnHilliard/mesh2DCoupled.py
index f917d42..5cbf096 100755
--- a/examples/cahnHilliard/mesh2DCoupled.py
+++ b/examples/cahnHilliard/mesh2DCoupled.py
@@ -198,12 +198,13 @@ a vector format.
 True
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/cahnHilliard/mesh3D.py b/examples/cahnHilliard/mesh3D.py
index 1527661..ef0500b 100755
--- a/examples/cahnHilliard/mesh3D.py
+++ b/examples/cahnHilliard/mesh3D.py
@@ -106,12 +106,13 @@ evolution of their problem.
    :align: center
    :alt: snapshot of Cahn-Hilliard phase separation in 3D with cutaway
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/cahnHilliard/sphere.py b/examples/cahnHilliard/sphere.py
index 116388f..32b7f53 100755
--- a/examples/cahnHilliard/sphere.py
+++ b/examples/cahnHilliard/sphere.py
@@ -141,12 +141,13 @@ evolution of their problem.
    :alt: Cahn-Hilliard phase separation on the surface of a sphere with a rendering of the mesh
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/cahnHilliard/sphereDaemon.py b/examples/cahnHilliard/sphereDaemon.py
index 04a470c..e798b5a 100644
--- a/examples/cahnHilliard/sphereDaemon.py
+++ b/examples/cahnHilliard/sphereDaemon.py
@@ -2,7 +2,7 @@ import sys
 
 try:
     from mayavi import mlab
-except ImportError, e:
+except ImportError as e:
     from enthought.mayavi import mlab
 
 from fipy.viewers.mayaviViewer.mayaviDaemon import MayaviDaemon
diff --git a/examples/cahnHilliard/tanh1D.py b/examples/cahnHilliard/tanh1D.py
index 4bd8270..feb0868 100755
--- a/examples/cahnHilliard/tanh1D.py
+++ b/examples/cahnHilliard/tanh1D.py
@@ -183,12 +183,13 @@ We compare the analytical solution with the numerical result,
 1
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/chemotaxis/input.py b/examples/chemotaxis/input.py
index d27d949..d2c294a 100755
--- a/examples/chemotaxis/input.py
+++ b/examples/chemotaxis/input.py
@@ -58,6 +58,10 @@ Here are some test cases for the model.
     1
 
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 from examples.chemotaxis.parameters import parameters
 
@@ -84,7 +88,7 @@ RVar = CellVariable(mesh = mesh, value = params['R'], hasOld = 1)
 PN = P3Var + P2Var
 
 KMscCoeff = params['chiK'] * (RVar + 1) * (1 - KCVar - KMVar.cellVolumeAverage)
-KMspCoeff = params['lambdaK'] / (1 + PN / params['kappaK'])
+KMspCoeff = old_div(params['lambdaK'], (1 + old_div(PN, params['kappaK'])))
 KMEq = TransientTerm() - KMscCoeff + ImplicitSourceTerm(KMspCoeff)
 
 TMscCoeff = params['chiT'] * (1 - TCVar - TMVar.cellVolumeAverage)
@@ -95,27 +99,27 @@ TCscCoeff = params['lambdaT'] * (TMVar * KMVar).cellVolumeAverage
 TCspCoeff = params['lambdaTstar']
 TCEq = TransientTerm() - TCscCoeff + ImplicitSourceTerm(TCspCoeff) 
 
-PIP2PITP = PN / (PN / params['kappam'] + PN.cellVolumeAverage / params['kappac'] + 1) + params['zetaPITP']
+PIP2PITP = old_div(PN, (old_div(PN, params['kappam']) + old_div(PN.cellVolumeAverage, params['kappac']) + 1)) + params['zetaPITP']
 
 P3spCoeff = params['lambda3'] * (TMVar + params['zeta3T'])
-P3scCoeff = params['chi3'] * KMVar * (PIP2PITP / (1 + KMVar / params['kappa3']) + params['zeta3PITP']) + params['zeta3']
+P3scCoeff = params['chi3'] * KMVar * (old_div(PIP2PITP, (1 + old_div(KMVar, params['kappa3']))) + params['zeta3PITP']) + params['zeta3']
 P3Eq = TransientTerm() - DiffusionTerm(params['diffusionCoeff']) - P3scCoeff + ImplicitSourceTerm(P3spCoeff)
 
 P2scCoeff = scCoeff = params['chi2'] + params['lambda3'] * params['zeta3T'] * P3Var
 P2spCoeff = params['lambda2'] * (TMVar + params['zeta2T'])
 P2Eq = TransientTerm() - DiffusionTerm(params['diffusionCoeff']) - P2scCoeff + ImplicitSourceTerm(P2spCoeff)
 
-KCscCoeff = params['alphaKstar'] * params['lambdaK'] * (KMVar / (1 + PN / params['kappaK'])).cellVolumeAverage
-KCspCoeff = params['lambdaKstar'] / (params['kappaKstar'] + KCVar)
+KCscCoeff = params['alphaKstar'] * params['lambdaK'] * (old_div(KMVar, (1 + old_div(PN, params['kappaK'])))).cellVolumeAverage
+KCspCoeff = old_div(params['lambdaKstar'], (params['kappaKstar'] + KCVar))
 KCEq = TransientTerm() - KCscCoeff + ImplicitSourceTerm(KCspCoeff) 
 
 eqs = ((KMVar, KMEq), (TMVar, TMEq), (TCVar, TCEq), (P3Var, P3Eq), (P2Var, P2Eq), (KCVar, KCEq))
 
 if __name__ == '__main__':
 
-    v1 = KMVar / KMVar.cellVolumeAverage
-    v2 = PN / PN.cellVolumeAverage
-    v3 = TMVar / TMVar.cellVolumeAverage
+    v1 = old_div(KMVar, KMVar.cellVolumeAverage)
+    v2 = old_div(PN, PN.cellVolumeAverage)
+    v3 = old_div(TMVar, TMVar.cellVolumeAverage)
     v1.setName('KM')
     v2.setName('PN')
     v3.setName('TM')
@@ -130,7 +134,7 @@ if __name__ == '__main__':
         for var, eqn in eqs:
             eqn.solve(var, dt = 1.)
 
-    RVar[:] = params['S'] + (1 + params['S']) * params['G'] * cos((2 * pi * mesh.cellCenters[0]) / L)
+    RVar[:] = params['S'] + (1 + params['S']) * params['G'] * cos(old_div((2 * pi * mesh.cellCenters[0]), L))
 
     for i in range(100):
         for var, eqn in eqs:
@@ -141,7 +145,7 @@ if __name__ == '__main__':
 
     KMViewer.plot()
 
-    raw_input("finished")
+    input("finished")
 
     
 
diff --git a/examples/chemotaxis/input2D.py b/examples/chemotaxis/input2D.py
index c4b1227..51dd572 100755
--- a/examples/chemotaxis/input2D.py
+++ b/examples/chemotaxis/input2D.py
@@ -58,6 +58,10 @@ Here are some test cases for the model.
     1
 
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 from examples.chemotaxis.parameters import parameters
 from fipy import *
@@ -84,7 +88,7 @@ RVar = CellVariable(mesh = mesh, value = params['R'], hasOld = 1)
 PN = P3Var + P2Var
 
 KMscCoeff = params['chiK'] * (RVar + 1) * (1 - KCVar - KMVar.cellVolumeAverage)
-KMspCoeff = params['lambdaK'] / (1 + PN / params['kappaK'])
+KMspCoeff = old_div(params['lambdaK'], (1 + old_div(PN, params['kappaK'])))
 KMEq = TransientTerm() - KMscCoeff + ImplicitSourceTerm(KMspCoeff)
 
 TMscCoeff = params['chiT'] * (1 - TCVar - TMVar.cellVolumeAverage)
@@ -95,33 +99,33 @@ TCscCoeff = params['lambdaT'] * (TMVar * KMVar).cellVolumeAverage
 TCspCoeff = params['lambdaTstar']
 TCEq = TransientTerm() - TCscCoeff + ImplicitSourceTerm(TCspCoeff) 
 
-PIP2PITP = PN / (PN / params['kappam'] + PN.cellVolumeAverage / params['kappac'] + 1) + params['zetaPITP']
+PIP2PITP = old_div(PN, (old_div(PN, params['kappam']) + old_div(PN.cellVolumeAverage, params['kappac']) + 1)) + params['zetaPITP']
 
 P3spCoeff = params['lambda3'] * (TMVar + params['zeta3T'])
-P3scCoeff = params['chi3'] * KMVar * (PIP2PITP / (1 + KMVar / params['kappa3']) + params['zeta3PITP']) + params['zeta3']
+P3scCoeff = params['chi3'] * KMVar * (old_div(PIP2PITP, (1 + old_div(KMVar, params['kappa3']))) + params['zeta3PITP']) + params['zeta3']
 P3Eq = TransientTerm() - DiffusionTerm(params['diffusionCoeff']) - P3scCoeff + ImplicitSourceTerm(P3spCoeff)
 
 P2scCoeff = scCoeff = params['chi2'] + params['lambda3'] * params['zeta3T'] * P3Var
 P2spCoeff = params['lambda2'] * (TMVar + params['zeta2T'])
 P2Eq = TransientTerm() - DiffusionTerm(params['diffusionCoeff']) - P2scCoeff + ImplicitSourceTerm(P2spCoeff)
 
-KCscCoeff = params['alphaKstar'] * params['lambdaK'] * (KMVar / (1 + PN / params['kappaK'])).cellVolumeAverage
-KCspCoeff = params['lambdaKstar'] / (params['kappaKstar'] + KCVar)
+KCscCoeff = params['alphaKstar'] * params['lambdaK'] * (old_div(KMVar, (1 + old_div(PN, params['kappaK'])))).cellVolumeAverage
+KCspCoeff = old_div(params['lambdaKstar'], (params['kappaKstar'] + KCVar))
 KCEq = TransientTerm() - KCscCoeff + ImplicitSourceTerm(KCspCoeff) 
 
 eqs = ((KMVar, KMEq), (TMVar, TMEq), (TCVar, TCEq), (P3Var, P3Eq), (P2Var, P2Eq), (KCVar, KCEq))
 
 if __name__ == '__main__':
 
-    PNView = PN / PN.cellVolumeAverage
+    PNView = old_div(PN, PN.cellVolumeAverage)
     PNView.setName('PN')
     PNViewer = Viewer(PNView, datamax=2., datamin=0., title='')
     
-    KMView = KMVar / KMVar.cellVolumeAverage
+    KMView = old_div(KMVar, KMVar.cellVolumeAverage)
     KMView.setName('KM')
     KMViewer = Viewer(KMView, datamax=2., datamin=0., title='')
     
-    TMView = TMVar / TMVar.cellVolumeAverage
+    TMView = old_div(TMVar, TMVar.cellVolumeAverage)
     TMView.setName('TM')
     TMViewer = Viewer(TMView, datamax=2., datamin=0., title='')
 
@@ -133,7 +137,7 @@ if __name__ == '__main__':
 
     x, y = mesh.cellCenters
 
-    RVar[:] = L / sqrt((x - L / 2)**2 + (y - 2 * L)**2)
+    RVar[:] = old_div(L, sqrt((x - old_div(L, 2))**2 + (y - 2 * L)**2))
     
     for i in range(100):
         for var, eqn in eqs:
@@ -145,7 +149,7 @@ if __name__ == '__main__':
         KMViewer.plot()
         TMViewer.plot()
 
-    raw_input("finished")
+    input("finished")
 
     
 
diff --git a/examples/convection/advection/explicitUpwind.py b/examples/convection/advection/explicitUpwind.py
index b6d9e73..43968e3 100755
--- a/examples/convection/advection/explicitUpwind.py
+++ b/examples/convection/advection/explicitUpwind.py
@@ -36,6 +36,10 @@
 This example shows the failure of advecting a square pulse with a first
 order explicit upwind scheme.
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 from fipy import *
 
@@ -43,7 +47,7 @@ valueLeft = 0.
 valueRight = 0.
 L = 10.
 nx = 400
-dx = L / nx
+dx = old_div(L, nx)
 cfl = 0.1
 velocity = -1.
 timeStepDuration = cfl * dx / abs(velocity)
@@ -73,4 +77,4 @@ if __name__ == '__main__':
                  solver = LinearLUSolver(tolerance=1.e-15, iterations=2000))
         viewer.plot()
     viewer.plot()
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/advection/implicitUpwind.py b/examples/convection/advection/implicitUpwind.py
index 06d2512..6a39165 100755
--- a/examples/convection/advection/implicitUpwind.py
+++ b/examples/convection/advection/implicitUpwind.py
@@ -36,6 +36,10 @@
 This example shows the failure of advecting a square pulse with a first
 order implicit upwind scheme.
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 from fipy import *
 
@@ -43,7 +47,7 @@ valueLeft = 0.
 valueRight = 0.
 L = 10.
 nx = 400
-dx = L / nx
+dx = old_div(L, nx)
 cfl = 0.01
 velocity = 1.
 timeStepDuration = cfl * dx / abs(velocity)
@@ -68,11 +72,11 @@ if __name__ == '__main__':
     
     viewer = Viewer(vars=(var,))
     viewer.plot()
-    raw_input("press key to continue")
+    input("press key to continue")
     for step in range(steps):
         eq.solve(var,
                  dt = timeStepDuration,
                  solver = LinearLUSolver(tolerance = 1.e-15))
         viewer.plot()
     viewer.plot()
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/advection/vanLeerUpwind.py b/examples/convection/advection/vanLeerUpwind.py
index 6f20883..9b3f6f3 100755
--- a/examples/convection/advection/vanLeerUpwind.py
+++ b/examples/convection/advection/vanLeerUpwind.py
@@ -61,6 +61,11 @@ should do better than this.
 >>> print var1.max() > 0.77
 1
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 __docformat__ = 'restructuredtext'
 
@@ -68,7 +73,7 @@ from fipy import *
      
 L = 20.
 nx = 40
-dx = L / nx
+dx = old_div(L, nx)
 cfl = 0.5
 velocity = 1.0
 dt = cfl * dx / velocity
@@ -110,9 +115,9 @@ if __name__ == '__main__':
         viewer1.plot()
         viewer2.plot()
 
-    newVar2[:nx / 4] = var2[nx / 4:]
-    newVar2[nx / 4:] = var2[:nx / 4]
+    newVar2[:old_div(nx, 4)] = var2[old_div(nx, 4):]
+    newVar2[old_div(nx, 4):] = var2[:old_div(nx, 4)]
 
-    print 'maximum absolute difference between periodic and non-periodic grids:',abs(var1[nx / 4:3 * nx / 4] - newVar2).max()
+    print('maximum absolute difference between periodic and non-periodic grids:',abs(var1[old_div(nx, 4):3 * nx / 4] - newVar2).max())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1D/cylindricalMesh1D.py b/examples/convection/exponential1D/cylindricalMesh1D.py
index bb0282d..439ade8 100644
--- a/examples/convection/exponential1D/cylindricalMesh1D.py
+++ b/examples/convection/exponential1D/cylindricalMesh1D.py
@@ -127,10 +127,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1D/cylindricalMesh1DNonUniform.py b/examples/convection/exponential1D/cylindricalMesh1DNonUniform.py
index decaae4..2f18aaa 100644
--- a/examples/convection/exponential1D/cylindricalMesh1DNonUniform.py
+++ b/examples/convection/exponential1D/cylindricalMesh1DNonUniform.py
@@ -130,10 +130,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1D/mesh1D.py b/examples/convection/exponential1D/mesh1D.py
index dc1a566..c3c4fd6 100755
--- a/examples/convection/exponential1D/mesh1D.py
+++ b/examples/convection/exponential1D/mesh1D.py
@@ -122,10 +122,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1D/tri2D.py b/examples/convection/exponential1D/tri2D.py
index d8601bb..e8a3ca0 100755
--- a/examples/convection/exponential1D/tri2D.py
+++ b/examples/convection/exponential1D/tri2D.py
@@ -85,10 +85,11 @@ The analytical solution test for this problem is given by:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1DBack/mesh1D.py b/examples/convection/exponential1DBack/mesh1D.py
index d579532..daaabef 100755
--- a/examples/convection/exponential1DBack/mesh1D.py
+++ b/examples/convection/exponential1DBack/mesh1D.py
@@ -77,11 +77,12 @@ We test the solution against the analytical result:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
     
diff --git a/examples/convection/exponential1DSource/mesh1D.py b/examples/convection/exponential1DSource/mesh1D.py
index dc0e0e3..91db788 100755
--- a/examples/convection/exponential1DSource/mesh1D.py
+++ b/examples/convection/exponential1DSource/mesh1D.py
@@ -120,10 +120,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential1DSource/tri2D.py b/examples/convection/exponential1DSource/tri2D.py
index 79745a0..f6fdfc1 100755
--- a/examples/convection/exponential1DSource/tri2D.py
+++ b/examples/convection/exponential1DSource/tri2D.py
@@ -91,10 +91,11 @@ The analytical solution test for this problem is given by:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential2D/cylindricalMesh2D.py b/examples/convection/exponential2D/cylindricalMesh2D.py
index 6dd9a62..8b7a370 100644
--- a/examples/convection/exponential2D/cylindricalMesh2D.py
+++ b/examples/convection/exponential2D/cylindricalMesh2D.py
@@ -129,10 +129,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential2D/cylindricalMesh2DNonUniform.py b/examples/convection/exponential2D/cylindricalMesh2DNonUniform.py
index 053a318..e6695b5 100644
--- a/examples/convection/exponential2D/cylindricalMesh2DNonUniform.py
+++ b/examples/convection/exponential2D/cylindricalMesh2DNonUniform.py
@@ -127,10 +127,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars=var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/exponential2D/mesh2D.py b/examples/convection/exponential2D/mesh2D.py
index 82ba4b1..eb7feeb 100755
--- a/examples/convection/exponential2D/mesh2D.py
+++ b/examples/convection/exponential2D/mesh2D.py
@@ -77,6 +77,7 @@ We test the solution against the analytical result:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 
@@ -84,5 +85,5 @@ if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
     
diff --git a/examples/convection/exponential2D/tri2D.py b/examples/convection/exponential2D/tri2D.py
index 6b00eba..320d46e 100755
--- a/examples/convection/exponential2D/tri2D.py
+++ b/examples/convection/exponential2D/tri2D.py
@@ -76,11 +76,12 @@ The analytical solution test for this problem is given by:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
      
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
     
diff --git a/examples/convection/powerLaw1D/mesh1D.py b/examples/convection/powerLaw1D/mesh1D.py
index 4a8ee86..60a9352 100755
--- a/examples/convection/powerLaw1D/mesh1D.py
+++ b/examples/convection/powerLaw1D/mesh1D.py
@@ -79,6 +79,7 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
      
 __docformat__ = 'restructuredtext'
 
@@ -86,4 +87,4 @@ if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/convection/powerLaw1D/tri2D.py b/examples/convection/powerLaw1D/tri2D.py
index 79e98553..c24b2e0 100755
--- a/examples/convection/powerLaw1D/tri2D.py
+++ b/examples/convection/powerLaw1D/tri2D.py
@@ -77,11 +77,12 @@ The analytical solution test for this problem is given by:
 ...     viewer = Viewer(vars = var)
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
   
diff --git a/examples/convection/robin.py b/examples/convection/robin.py
index e65addf..2007d8d 100644
--- a/examples/convection/robin.py
+++ b/examples/convection/robin.py
@@ -110,10 +110,11 @@ where
 True
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/diffusion/anisotropy.py b/examples/diffusion/anisotropy.py
index 8e8c277..52df520 100644
--- a/examples/diffusion/anisotropy.py
+++ b/examples/diffusion/anisotropy.py
@@ -130,10 +130,11 @@ Compare with the analytical solution (within 5% accuracy).
 True
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/diffusion/coupled.py b/examples/diffusion/coupled.py
index 6791caa..adba1ae 100644
--- a/examples/diffusion/coupled.py
+++ b/examples/diffusion/coupled.py
@@ -146,11 +146,12 @@ seperate governing equations and to couple them. If they represent two
 components of a vector field, then the vector formulation is obviously more
 natural. FiPy will solve the same matrix system either way.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/diffusion/electrostatics.py b/examples/diffusion/electrostatics.py
index a4fac62..d7c1b76 100755
--- a/examples/diffusion/electrostatics.py
+++ b/examples/diffusion/electrostatics.py
@@ -206,11 +206,12 @@ and once again view the result
    :alt: electrostatic potential generated by negative charge on left
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
  
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/diffusion/explicit/mesh1D.py b/examples/diffusion/explicit/mesh1D.py
index 14cae3a..e090614 100755
--- a/examples/diffusion/explicit/mesh1D.py
+++ b/examples/diffusion/explicit/mesh1D.py
@@ -105,10 +105,11 @@ If the problem is run interactively, we can view the result:
 ...     viewer = Viewer(vars = (var,))
 ...     viewer.plot()
 """
+from builtins import input
  
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input('finished')
+    input('finished')
diff --git a/examples/diffusion/explicit/mixedelement.py b/examples/diffusion/explicit/mixedelement.py
index ca5c1c5..ef55c80 100755
--- a/examples/diffusion/explicit/mixedelement.py
+++ b/examples/diffusion/explicit/mixedelement.py
@@ -66,6 +66,11 @@ The result is again tested in the same way:
     1
 
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 from fipy import *
 
 dx = 1.
@@ -118,10 +123,10 @@ if __name__ == '__main__':
         var.updateOld()        
         eqn.solve(var, dt=timeStepDuration)
         if(not (step % 100)):
-            print (step / 100)
-    print var
+            print (old_div(step, 100))
+    print(var)
     theMask = array([[10, 1, 20, 2]])
     viewer.plot()
 ##     viewer.plot(mask = theMask, graphwidth = 15, graphheight = 3)
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/diffusion/explicit/tri2D.py b/examples/diffusion/explicit/tri2D.py
index a2326fb..ffc2822 100755
--- a/examples/diffusion/explicit/tri2D.py
+++ b/examples/diffusion/explicit/tri2D.py
@@ -63,6 +63,9 @@ The result is again tested in the same way:
     1
 
 """
+from __future__ import print_function
+from builtins import input
+from builtins import range
 
 from fipy import *
 
@@ -104,8 +107,8 @@ if __name__ == '__main__':
     
     for step in range(steps):
         eq.solve(var, solver = solver, dt = timeStepDuration)
-    print var
+    print(var)
     viewer = Viewer(vars = var)
     viewer.plot()
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/diffusion/nthOrder/input4thOrder-line.py b/examples/diffusion/nthOrder/input4thOrder-line.py
index 591e1ca..3030a9b 100644
--- a/examples/diffusion/nthOrder/input4thOrder-line.py
+++ b/examples/diffusion/nthOrder/input4thOrder-line.py
@@ -46,13 +46,17 @@
    1
 
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
 
 Lx = 1.
 nx = 100000
-dx = Lx / nx
+dx = old_div(Lx, nx)
 
 mesh = Grid1D(dx = dx, nx = nx)
 
@@ -75,5 +79,5 @@ if __name__ == '__main__':
     viewer = Viewer(var)
     viewer.plot()
 
-    print var.allclose(mesh.cellCenters[0], atol = 10)
-    raw_input("finished")
+    print(var.allclose(mesh.cellCenters[0], atol = 10))
+    input("finished")
diff --git a/examples/diffusion/nthOrder/input4thOrder1D.py b/examples/diffusion/nthOrder/input4thOrder1D.py
index ccac613..148a252 100755
--- a/examples/diffusion/nthOrder/input4thOrder1D.py
+++ b/examples/diffusion/nthOrder/input4thOrder1D.py
@@ -127,9 +127,10 @@ If the problem is run interactively, we can view the result:
    :alt: solution to biharmonic equation
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input('finished')
+    input('finished')
diff --git a/examples/diffusion/steadyState/mesh1D/inputPeriodic.py b/examples/diffusion/steadyState/mesh1D/inputPeriodic.py
index e7f270b..cdd8c8c 100755
--- a/examples/diffusion/steadyState/mesh1D/inputPeriodic.py
+++ b/examples/diffusion/steadyState/mesh1D/inputPeriodic.py
@@ -77,10 +77,11 @@ The result of the calculation will be the average value over the domain.
 1
    
 """
+from builtins import input
 
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/steadyState/mesh1D/tri2Dinput.py b/examples/diffusion/steadyState/mesh1D/tri2Dinput.py
index 47761f8..435cfd5 100755
--- a/examples/diffusion/steadyState/mesh1D/tri2Dinput.py
+++ b/examples/diffusion/steadyState/mesh1D/tri2Dinput.py
@@ -66,6 +66,8 @@ tolerance of `1e-10`.
     1
 
 """
+from __future__ import print_function
+from builtins import input
 
 __docformat__ = 'restructuredtext'
 
@@ -90,5 +92,5 @@ if __name__ == '__main__':
     x = mesh.cellCenters[0]
     Lx = nx * dx
     analyticalArray = valueLeft + (valueRight - valueLeft) * x / Lx
-    print var.allclose(analyticalArray)
-    raw_input("finished")
+    print(var.allclose(analyticalArray))
+    input("finished")
diff --git a/examples/diffusion/steadyState/mesh20x20/gmshinput.py b/examples/diffusion/steadyState/mesh20x20/gmshinput.py
index a62a6d5..7da3d84 100755
--- a/examples/diffusion/steadyState/mesh20x20/gmshinput.py
+++ b/examples/diffusion/steadyState/mesh20x20/gmshinput.py
@@ -43,6 +43,7 @@ the non-orthogonality error, this uses a SkewedGrid2D, which is a
 Grid2D with each interior vertex moved in a random direction.
 
 """
+from builtins import input
 
 if __name__ == '__main__':
     import sys
@@ -82,5 +83,5 @@ if __name__ == '__main__':
     viewer.plot()
     NOViewer.plot()
 
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/diffusion/steadyState/mesh20x20/isotropy.py b/examples/diffusion/steadyState/mesh20x20/isotropy.py
index abd8ce8..abfb0ee 100755
--- a/examples/diffusion/steadyState/mesh20x20/isotropy.py
+++ b/examples/diffusion/steadyState/mesh20x20/isotropy.py
@@ -64,6 +64,7 @@ the diffusion coefficient, even though the coefficient is isotropic.
 >>> print var.allclose(analyticalArray, atol = 0.025)
 1
 """
+from builtins import input
 
 __docformat__ = 'restructuredtext'
 
@@ -71,4 +72,4 @@ if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/diffusion/steadyState/mesh20x20/orthoerror.py b/examples/diffusion/steadyState/mesh20x20/orthoerror.py
index 2b80a53..bd65b74 100755
--- a/examples/diffusion/steadyState/mesh20x20/orthoerror.py
+++ b/examples/diffusion/steadyState/mesh20x20/orthoerror.py
@@ -38,6 +38,9 @@ This test file generates lots of different SkewedGrid2D meshes, each with a diff
 and runs a 1D diffusion problem on them all. It ocmputes the RMS non-orthogonality and the RMS error
 for each mesh and displays them in a graph, allowing the relationship of error to non-orthogonality to be investigated.
 """
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 
 if __name__ == '__main__':
     
@@ -71,8 +74,8 @@ if __name__ == '__main__':
         analyticalArray = valueLeft + (valueRight - valueLeft) * x / 20
         errorArray = varArray - analyticalArray
         nonOrthoArray = mesh._nonOrthogonality
-        RMSError = (add.reduce(errorArray * errorArray) / len(errorArray)) ** 0.5
-        RMSNonOrtho = (add.reduce(nonOrthoArray * nonOrthoArray) / len(nonOrthoArray)) ** 0.5
+        RMSError = (old_div(add.reduce(errorArray * errorArray), len(errorArray))) ** 0.5
+        RMSNonOrtho = (old_div(add.reduce(nonOrthoArray * nonOrthoArray), len(nonOrthoArray))) ** 0.5
 
         RMSNonOrthoList += [RMSNonOrtho]
         RMSErrorList += [RMSError]
diff --git a/examples/diffusion/steadyState/mesh20x20/tri2Dinput.py b/examples/diffusion/steadyState/mesh20x20/tri2Dinput.py
index e77fe00..ec03589 100755
--- a/examples/diffusion/steadyState/mesh20x20/tri2Dinput.py
+++ b/examples/diffusion/steadyState/mesh20x20/tri2Dinput.py
@@ -47,6 +47,7 @@ The result is again tested in the same way:
     1
 
 """
+from builtins import input
 
 from fipy import *
 
@@ -71,4 +72,4 @@ if __name__ == '__main__':
     DiffusionTerm().solve(var)
     viewer = Viewer(vars = var)
     viewer.plot()
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/steadyState/mesh50x50/input.py b/examples/diffusion/steadyState/mesh50x50/input.py
index bb511c5..8106700 100755
--- a/examples/diffusion/steadyState/mesh50x50/input.py
+++ b/examples/diffusion/steadyState/mesh50x50/input.py
@@ -50,6 +50,7 @@ The result is again tested in the same way:
     1
 
 """
+from builtins import input
 
 __docformat__ = 'restructuredtext'
 
@@ -77,4 +78,4 @@ if __name__ == '__main__':
     
     viewer = Viewer(vars=var, datamin=0., datamax=1.)
     viewer.plot()
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/steadyState/mesh50x50/tri2Dinput.py b/examples/diffusion/steadyState/mesh50x50/tri2Dinput.py
index f148a48..0043477 100755
--- a/examples/diffusion/steadyState/mesh50x50/tri2Dinput.py
+++ b/examples/diffusion/steadyState/mesh50x50/tri2Dinput.py
@@ -54,6 +54,7 @@ The result is again tested in the same way:
     1
 
 """
+from builtins import input
 
 from fipy import *
 
@@ -78,4 +79,4 @@ if __name__ == '__main__':
     DiffusionTerm().solve(var)
     viewer = Viewer(vars = var)
     viewer.plot()
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/steadyState/otherMeshes/cubicalProblem.py b/examples/diffusion/steadyState/otherMeshes/cubicalProblem.py
index cea1ee7..926b20c 100755
--- a/examples/diffusion/steadyState/otherMeshes/cubicalProblem.py
+++ b/examples/diffusion/steadyState/otherMeshes/cubicalProblem.py
@@ -39,6 +39,7 @@
 Test case for the Grid3D. Diffusion problem with boundary conditions: 0 on front, 10 on back, and 5 on all other sides.
    
 """
+from builtins import input
 
 from fipy import *
 
@@ -89,4 +90,4 @@ if __name__ == '__main__':
     ##viewer7.plot(resolution = 0.2, xlabel = "X values (Z value = 7)", minval = valueFront, maxval = valueBack)
     ##raw_input("press enter to continue")
     ##viewer9.plot(resolution = 0.2, xlabel = "X values (Z value = 9)", minval = valueFront, maxval = valueBack)
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/steadyState/otherMeshes/grid3Dinput.py b/examples/diffusion/steadyState/otherMeshes/grid3Dinput.py
index 433df74..7a157cb 100755
--- a/examples/diffusion/steadyState/otherMeshes/grid3Dinput.py
+++ b/examples/diffusion/steadyState/otherMeshes/grid3Dinput.py
@@ -47,6 +47,7 @@ Test case for the Grid3D.
    True
 
 """
+from builtins import input
 
 from fipy import *
 
@@ -97,4 +98,4 @@ if __name__ == '__main__':
     eqn.solve(var2)
     viewer = Viewer(var2)
     viewer.plot()
-    raw_input("finished")
+    input("finished")
diff --git a/examples/diffusion/variable.py b/examples/diffusion/variable.py
index d6dfbb0..4f69701 100755
--- a/examples/diffusion/variable.py
+++ b/examples/diffusion/variable.py
@@ -50,6 +50,9 @@ A simple analytical answer can be used to test the result:
    1
 
 """
+from __future__ import division
+from builtins import input
+from past.utils import old_div
 
 from fipy import *
 
@@ -62,7 +65,7 @@ timeStepDuration = 1.
 
 L = 10.
 
-dx = L / nx
+dx = old_div(L, nx)
 dy = 1.
 
 mesh = Tri2D(dx, dy, nx, ny)
@@ -75,7 +78,7 @@ var = CellVariable(
 diffCoeff = FaceVariable(mesh = mesh, value = 1.0)
 
 x = mesh.faceCenters[0]
-diffCoeff.setValue(0.1, where=(L/4. <= x) & (x < 3. * L / 4.))
+diffCoeff.setValue(0.1, where=(old_div(L,4.) <= x) & (x < 3. * L / 4.))
 
 var.faceGrad.constrain([[1.], [0.]], mesh.facesRight)
 
@@ -84,4 +87,4 @@ var.constrain(valueLeft, mesh.facesLeft)
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input('finished')
+    input('finished')
diff --git a/examples/elphf/diffusion/mesh1D.py b/examples/elphf/diffusion/mesh1D.py
index 30de6fd..df18d4a 100755
--- a/examples/elphf/diffusion/mesh1D.py
+++ b/examples/elphf/diffusion/mesh1D.py
@@ -153,6 +153,7 @@ True
 >>> print substitutionals[1].allclose(0.45, rtol = 1e-7, atol = 1e-7)
 True
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
@@ -167,5 +168,5 @@ if __name__ == '__main__':
     
     # profile.stop()
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/elphf/diffusion/mesh1Ddimensional.py b/examples/elphf/diffusion/mesh1Ddimensional.py
index cd1f622..1538f36 100755
--- a/examples/elphf/diffusion/mesh1Ddimensional.py
+++ b/examples/elphf/diffusion/mesh1Ddimensional.py
@@ -151,6 +151,7 @@ we verify that the concentrations have become uniform
    The absolute tolerance `atol` must be in units compatible with the value to 
    be checked, but the relative tolerance `rtol` is dimensionless.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 
@@ -166,5 +167,5 @@ if __name__ == '__main__':
     
     # profile.stop()
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/elphf/diffusion/mesh2D.py b/examples/elphf/diffusion/mesh2D.py
index 70bf48b..7392485 100755
--- a/examples/elphf/diffusion/mesh2D.py
+++ b/examples/elphf/diffusion/mesh2D.py
@@ -189,6 +189,7 @@ and verify that the correct uniform concentrations are achieved
 
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
@@ -203,5 +204,5 @@ if __name__ == '__main__':
     
     # profile.stop()
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/elphf/input.py b/examples/elphf/input.py
index 6960275..229e52d 100755
--- a/examples/elphf/input.py
+++ b/examples/elphf/input.py
@@ -364,6 +364,7 @@ their respective phases
     >>> allclose(ends, (0.1, 0.2), rtol = 3e-3, atol = 3e-3)
     1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 ## def _test(): 
@@ -386,5 +387,5 @@ if __name__ == '__main__':
 
     # profile.stop()
             
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/elphf/phase.py b/examples/elphf/phase.py
index 1bb29e0..ebb6de8 100755
--- a/examples/elphf/phase.py
+++ b/examples/elphf/phase.py
@@ -197,6 +197,7 @@ If we are running interactively, we plot the error
    :align: center
    :alt: error in solution to steady-state phase field equation
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
@@ -211,5 +212,5 @@ if __name__ == '__main__':
 
 ##     profile.stop()
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/elphf/phaseDiffusion.py b/examples/elphf/phaseDiffusion.py
index 16f9c1c..324b2b9 100755
--- a/examples/elphf/phaseDiffusion.py
+++ b/examples/elphf/phaseDiffusion.py
@@ -409,12 +409,13 @@ their respective phases
 >>> numerix.allclose(substitutionals[1](((0., L),)), (0.1, 0.2), rtol = 3e-3, atol = 3e-3)
 1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == "__main__": 
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
 
 ## if __name__ == '__main__':
 ##     ## from fipy.tools.profiler.profiler import Profiler
diff --git a/examples/elphf/poisson.py b/examples/elphf/poisson.py
index b3df5b6..62c8434 100755
--- a/examples/elphf/poisson.py
+++ b/examples/elphf/poisson.py
@@ -214,11 +214,12 @@ and again view the result
 >>> if __name__ == '__main__':
 ...     viewer.plot()
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
  
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 	    
-    raw_input("finished")
+    input("finished")
 
diff --git a/examples/flow/stokesCavity.py b/examples/flow/stokesCavity.py
index 10d0735..8b5055a 100755
--- a/examples/flow/stokesCavity.py
+++ b/examples/flow/stokesCavity.py
@@ -336,9 +336,10 @@ Test values in the last cell.
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript(__name__))
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/advection/circle.py b/examples/levelSet/advection/circle.py
index 8851823..b2274ca 100755
--- a/examples/levelSet/advection/circle.py
+++ b/examples/levelSet/advection/circle.py
@@ -124,9 +124,10 @@ the result is more accurate,
 1
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/advection/mesh1D.py b/examples/levelSet/advection/mesh1D.py
index 5f14221..4a6953b 100755
--- a/examples/levelSet/advection/mesh1D.py
+++ b/examples/levelSet/advection/mesh1D.py
@@ -107,9 +107,10 @@ The result can be tested with the following code:
 1
    
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/advection/trench.py b/examples/levelSet/advection/trench.py
index 50d9870..46051a9 100755
--- a/examples/levelSet/advection/trench.py
+++ b/examples/levelSet/advection/trench.py
@@ -107,9 +107,10 @@ Advect the interface and check the position.
 1
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/distanceFunction/circle.py b/examples/levelSet/distanceFunction/circle.py
index 13239fb..4a2535d 100755
--- a/examples/levelSet/distanceFunction/circle.py
+++ b/examples/levelSet/distanceFunction/circle.py
@@ -114,9 +114,10 @@ The result can be tested with the following commands.
 >>> print numerix.allclose(var, trialValues) #doctest: +LSM
 True
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/distanceFunction/interior.py b/examples/levelSet/distanceFunction/interior.py
index c6e1881..bf594f3 100755
--- a/examples/levelSet/distanceFunction/interior.py
+++ b/examples/levelSet/distanceFunction/interior.py
@@ -69,6 +69,7 @@ Do the tests:
 1
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -99,4 +100,4 @@ if __name__ == '__main__':
     var.calcDistanceFunction(order=1)
     viewer = Viewer(vars=var, datamin=-5., datamax=5.)
     viewer.plot()
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/distanceFunction/mesh1D.py b/examples/levelSet/distanceFunction/mesh1D.py
index 38c8639..04ba3b2 100755
--- a/examples/levelSet/distanceFunction/mesh1D.py
+++ b/examples/levelSet/distanceFunction/mesh1D.py
@@ -89,9 +89,10 @@ The result can be tested with the following commands.
 1
 
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/distanceFunction/square.py b/examples/levelSet/distanceFunction/square.py
index da1ede4..6fe9eea 100755
--- a/examples/levelSet/distanceFunction/square.py
+++ b/examples/levelSet/distanceFunction/square.py
@@ -72,6 +72,9 @@ Do the tests:
 1
 
 """
+from __future__ import division
+from builtins import input
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -94,10 +97,10 @@ var = DistanceVariable(
     )
 
 x, y = mesh.cellCenters
-var.setValue(1, where=((Lx / 3. < x) & (x < 2. * Lx / 3.)) & ((Ly / 3. < y) & (y < 2. * Ly / 3)))
+var.setValue(1, where=((old_div(Lx, 3.) < x) & (x < 2. * Lx / 3.)) & ((old_div(Ly, 3.) < y) & (y < 2. * Ly / 3)))
 
 if __name__ == '__main__':
     var.calcDistanceFunction(order=1)
     viewer = Viewer(vars=var, maxval=-5., minval=5.)
     viewer.plot()
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/electroChem/adsorbingSurfactantEquation.py b/examples/levelSet/electroChem/adsorbingSurfactantEquation.py
index 3d4f64a..a429ae9 100755
--- a/examples/levelSet/electroChem/adsorbingSurfactantEquation.py
+++ b/examples/levelSet/electroChem/adsorbingSurfactantEquation.py
@@ -33,6 +33,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.terms.implicitSourceTerm import ImplicitSourceTerm
@@ -41,7 +44,7 @@ from fipy.terms.explicitUpwindConvectionTerm import ExplicitUpwindConvectionTerm
 from fipy.variables.surfactantConvectionVariable import SurfactantConvectionVariable
 from fipy.terms.transientTerm import TransientTerm
 
-class AdsorbingSurfactantEquation():
+class AdsorbingSurfactantEquation(object):
     r"""
 
     The `AdsorbingSurfactantEquation` object solves the
@@ -287,7 +290,7 @@ class AdsorbingSurfactantEquation():
             total += var.interfaceVar
         maxVar = (total > 1) * distanceVar._cellInterfaceFlag
 
-        val = distanceVar.cellInterfaceAreas / mesh.cellVolumes
+        val = old_div(distanceVar.cellInterfaceAreas, mesh.cellVolumes)
         for var in vars[1:]:
             val -= distanceVar._cellInterfaceFlag * var
         
diff --git a/examples/levelSet/electroChem/adsorption.py b/examples/levelSet/electroChem/adsorption.py
index 9683983..b2f8da4 100755
--- a/examples/levelSet/electroChem/adsorption.py
+++ b/examples/levelSet/electroChem/adsorption.py
@@ -96,10 +96,16 @@ Compare the analaytical and numerical results:
 
 
 """
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
-from adsorbingSurfactantEquation import AdsorbingSurfactantEquation
+from .adsorbingSurfactantEquation import AdsorbingSurfactantEquation
 
 # parameter values
 
@@ -114,7 +120,7 @@ dt = 0.001
 
 ## build the mesh
 
-dx = L / (nx - 1.5)
+dx = old_div(L, (nx - 1.5))
 from fipy.tools import serialComm
 mesh = Grid1D(nx = nx, dx = dx, communicator=serialComm)
 
@@ -131,7 +137,7 @@ bulkVar = CellVariable(mesh = mesh, value = cinf)
 
 surfactantVar = SurfactantVariable(distanceVar = distanceVar)
 
-from surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
+from .surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
 bulkEqn = buildSurfactantBulkDiffusionEquation(bulkVar,
                                           distanceVar = distanceVar,
                                           surfactantVar = surfactantVar,
@@ -175,11 +181,11 @@ if __name__ == "__main__":
         ## evaluate the analytical and numerical solution and plot
 
         theta = surfactantVar.interfaceVar[1]
-        print "theta:",theta
+        print("theta:",theta)
 
         ## do a time step
         surfEqn.solve(surfactantVar, dt = dt)
         bulkEqn.solve(bulkVar, dt = dt)
         currentTime += dt
 
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/electroChem/gapFillMesh.py b/examples/levelSet/electroChem/gapFillMesh.py
index f5c253e..2385851 100755
--- a/examples/levelSet/electroChem/gapFillMesh.py
+++ b/examples/levelSet/electroChem/gapFillMesh.py
@@ -44,6 +44,8 @@ boundary layer. This region consists of very large elements and is
 only used for the diffusion in the boundary layer.
 
 """
+from __future__ import division
+from past.utils import old_div
 
 __docformat__ = 'restructuredtext'
 
@@ -123,14 +125,14 @@ class GapFillMesh(Gmsh2D):
         """
 
         # Calculate the fine region cell counts.
-        nx = int(desiredDomainWidth / cellSize)
-        ny = int(desiredFineRegionHeight / cellSize) 
+        nx = int(old_div(desiredDomainWidth, cellSize))
+        ny = int(old_div(desiredFineRegionHeight, cellSize)) 
 
         # Calculate the actual mesh dimensions
         actualFineRegionHeight = ny * cellSize
         actualDomainWidth = nx * cellSize
         boundaryLayerHeight = desiredDomainHeight - actualFineRegionHeight - transitionRegionHeight
-        numberOfBoundaryLayerCells = int(boundaryLayerHeight / actualDomainWidth)
+        numberOfBoundaryLayerCells = int(old_div(boundaryLayerHeight, actualDomainWidth))
 
         # Build the fine region mesh.
         self.fineMesh = Grid2D(nx=nx, ny=ny, dx=cellSize, dy=cellSize, communicator=serialComm)
diff --git a/examples/levelSet/electroChem/gold.py b/examples/levelSet/electroChem/gold.py
index 48cde09..6b50036 100644
--- a/examples/levelSet/electroChem/gold.py
+++ b/examples/levelSet/electroChem/gold.py
@@ -100,13 +100,17 @@ resemble the image below.
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from __future__ import division
+from __future__ import absolute_import
+from builtins import input
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
-from trenchMesh import TrenchMesh
-from gapFillDistanceVariable  import GapFillDistanceVariable
-from metalIonDiffusionEquation import buildMetalIonDiffusionEquation
-from adsorbingSurfactantEquation import AdsorbingSurfactantEquation
+from .trenchMesh import TrenchMesh
+from .gapFillDistanceVariable  import GapFillDistanceVariable
+from .metalIonDiffusionEquation import buildMetalIonDiffusionEquation
+from .adsorbingSurfactantEquation import AdsorbingSurfactantEquation
 
 def runGold(faradaysConstant=9.6e4,
             consumptionRateConstant=2.6e+6,
@@ -188,7 +192,7 @@ def runGold(faradaysConstant=9.6e4,
     if displayViewers:
 
         try:
-            from mayaviSurfactantViewer import MayaviSurfactantViewer
+            from .mayaviSurfactantViewer import MayaviSurfactantViewer
             viewer = MayaviSurfactantViewer(distanceVar, catalystVar.interfaceVar, zoomFactor = 1e6, datamax=1.0, datamin=0.0, smooth = 1, title = 'catalyst coverage', animate=True)
             
         except:
@@ -234,11 +238,11 @@ def runGold(faradaysConstant=9.6e4,
 
     point = ((5e-09,), (1.15e-07,))
     value = 1.45346701e-09
-    return abs(float(distanceVar(point, order=1)) - value) < cellSize / 10.0
+    return abs(float(distanceVar(point, order=1)) - value) < old_div(cellSize, 10.0)
     
 __all__ = ["runGold"]
 
 if __name__ == '__main__':
     runGold(numberOfSteps = 300, cellSize = 0.05e-7)
-    raw_input("finished")
+    input("finished")
     
diff --git a/examples/levelSet/electroChem/leveler.py b/examples/levelSet/electroChem/leveler.py
index 1d31661..4d407e9 100755
--- a/examples/levelSet/electroChem/leveler.py
+++ b/examples/levelSet/electroChem/leveler.py
@@ -209,14 +209,18 @@ can be obtained by running this example.
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from __future__ import division
+from __future__ import absolute_import
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
-from surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
-from adsorbingSurfactantEquation import AdsorbingSurfactantEquation
-from trenchMesh import TrenchMesh
-from gapFillDistanceVariable import GapFillDistanceVariable
-from metalIonDiffusionEquation import buildMetalIonDiffusionEquation
+from .surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
+from .adsorbingSurfactantEquation import AdsorbingSurfactantEquation
+from .trenchMesh import TrenchMesh
+from .gapFillDistanceVariable import GapFillDistanceVariable
+from .metalIonDiffusionEquation import buildMetalIonDiffusionEquation
 
 def runLeveler(kLeveler=0.018, 
                bulkLevelerConcentration=0.02, 
@@ -321,7 +325,7 @@ def runLeveler(kLeveler=0.018,
         value = depositionRateVariable)   
 
     kAccelerator = rateConstant * numerix.exp(-alphaAdsorption * etaPrime)
-    kAcceleratorConsumption =  Bd + A / (numerix.exp(Ba * (overpotential + Vd)) + numerix.exp(Bb * (overpotential + Vd)))
+    kAcceleratorConsumption =  Bd + old_div(A, (numerix.exp(Ba * (overpotential + Vd)) + numerix.exp(Bb * (overpotential + Vd))))
     q = m * overpotential + b
 
     levelerSurfactantEquation = AdsorbingSurfactantEquation(
@@ -390,7 +394,7 @@ def runLeveler(kLeveler=0.018,
     if displayViewers:
         try:
             raise Exception
-            from mayaviSurfactantViewer import MayaviSurfactantViewer
+            from .mayaviSurfactantViewer import MayaviSurfactantViewer
             viewers = (
                 MayaviSurfactantViewer(distanceVar, acceleratorVar.interfaceVar, zoomFactor = 1e6, datamax=0.5, datamin=0.0, smooth = 1, title = 'accelerator coverage'),
                 MayaviSurfactantViewer(distanceVar, levelerVar.interfaceVar, zoomFactor = 1e6, datamax=0.5, datamin=0.0, smooth = 1, title = 'leveler coverage'))
@@ -436,7 +440,7 @@ def runLeveler(kLeveler=0.018,
 
     point = ((1.25e-08,), (3.125e-07,))
     value = 2.02815779e-08
-    return abs(float(distanceVar(point, order=1)) - value) < cellSize / 10.0
+    return abs(float(distanceVar(point, order=1)) - value) < old_div(cellSize, 10.0)
     
 __all__ = ["runLeveler"]
 
diff --git a/examples/levelSet/electroChem/lines.py b/examples/levelSet/electroChem/lines.py
index d2c2dc1..1840fdf 100644
--- a/examples/levelSet/electroChem/lines.py
+++ b/examples/levelSet/electroChem/lines.py
@@ -1,3 +1,5 @@
+from builtins import range
+from builtins import object
 93#!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -34,7 +36,7 @@
 
 __all__ = []
 
-class _Vertex:
+class _Vertex(object):
     def __init__(self, ID, x, y):
         self.ID = ID
         self.up = None
@@ -83,7 +85,7 @@ class _Vertex:
         self.setInLineTrue()
         self.down = vertex
 
-class _Line:
+class _Line(object):
     def __init__(self, seedVertex):
         if seedVertex.getUp() is not None or \
            seedVertex.getDown() is not None or \
diff --git a/examples/levelSet/electroChem/matplotlibSurfactantViewer.py b/examples/levelSet/electroChem/matplotlibSurfactantViewer.py
index c21ea4a..896700b 100644
--- a/examples/levelSet/electroChem/matplotlibSurfactantViewer.py
+++ b/examples/levelSet/electroChem/matplotlibSurfactantViewer.py
@@ -39,6 +39,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import zip
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -162,14 +165,14 @@ class MatplotlibSurfactantViewer(AbstractMatplotlibViewer):
         verts = numerix.array(zc.get_verts())
         IDs = numerix.array([mesh._getNearestCellID(vert[...,numerix.newaxis]) for vert in verts])
 
-        colors = pylab.cm.jet(( self.surfactantVar[IDs] - zmin) / (zmax - zmin))
-        segments = zip(verts[:-1], verts[1:])
+        colors = pylab.cm.jet(old_div(( self.surfactantVar[IDs] - zmin), (zmax - zmin)))
+        segments = list(zip(verts[:-1], verts[1:]))
         LC = matplotlib.collections.LineCollection(segments, colors=colors)
         
 #         CS.ax.add_collection(LC)
 
         verts = numerix.array((-verts[...,0], verts[..., 1])).swapaxes(0,1)
-        segments = zip(verts[:-1], verts[1:])
+        segments = list(zip(verts[:-1], verts[1:]))
         LC = matplotlib.collections.LineCollection(segments, colors=colors)
         
 #         CS.ax.add_collection(LC)
diff --git a/examples/levelSet/electroChem/mayaviSurfactantViewer.py b/examples/levelSet/electroChem/mayaviSurfactantViewer.py
index d0dbe7b..c7bb638 100644
--- a/examples/levelSet/electroChem/mayaviSurfactantViewer.py
+++ b/examples/levelSet/electroChem/mayaviSurfactantViewer.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+from builtins import range
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -143,9 +145,9 @@ class MayaviSurfactantViewer(AbstractViewer):
         shiftedCoords[:,0] = -coordinates[:,0] ##+ (maxX - minX)
         coordinates = numerix.concatenate((coordinates, shiftedCoords))
 
-        from lines import _getOrderedLines
+        from .lines import _getOrderedLines
 
-        lines = _getOrderedLines(range(2 * len(IDs)), coordinates, thresholdDistance = self.distanceVar.mesh._cellDistances.min() * 10)
+        lines = _getOrderedLines(list(range(2 * len(IDs))), coordinates, thresholdDistance = self.distanceVar.mesh._cellDistances.min() * 10)
 
         data = numerix.take(self.surfactantVar, IDs)
 
@@ -188,10 +190,10 @@ class MayaviSurfactantViewer(AbstractViewer):
         ## making lists as pyvtk doesn't know what to do with numpy arrays
 
         coords = list(coords)
-        coords = map(lambda coord: [float(coord[0]),float(coord[1]), float(coord[2])], coords)
+        coords = [[float(coord[0]),float(coord[1]), float(coord[2])] for coord in coords]
 
         data = list(data)
-        data = map(lambda item: float(item), data)
+        data = [float(item) for item in data]
 
         return (pyvtk.UnstructuredGrid(points = coords,
                                        poly_line = lines),
diff --git a/examples/levelSet/electroChem/simpleTrenchSystem.py b/examples/levelSet/electroChem/simpleTrenchSystem.py
index 9c0ce14..289146e 100644
--- a/examples/levelSet/electroChem/simpleTrenchSystem.py
+++ b/examples/levelSet/electroChem/simpleTrenchSystem.py
@@ -158,11 +158,17 @@ resemble the image below.
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
-from metalIonDiffusionEquation import buildMetalIonDiffusionEquation
-from adsorbingSurfactantEquation import AdsorbingSurfactantEquation
+from .metalIonDiffusionEquation import buildMetalIonDiffusionEquation
+from .adsorbingSurfactantEquation import AdsorbingSurfactantEquation
 
 def runSimpleTrenchSystem(faradaysConstant=9.6e4,
                           gasConstant=8.314,
@@ -194,7 +200,7 @@ def runSimpleTrenchSystem(faradaysConstant=9.6e4,
     cellsBelowTrench = 10
     
     yCells = cellsBelowTrench \
-             + int((trenchDepth + boundaryLayerDepth) / cellSize)
+             + int(old_div((trenchDepth + boundaryLayerDepth), cellSize))
 
     xCells = int(trenchSpacing / 2 / cellSize)
 
@@ -215,8 +221,8 @@ def runSimpleTrenchSystem(faradaysConstant=9.6e4,
 
     bottomHeight = cellsBelowTrench * cellSize
     trenchHeight = bottomHeight + trenchDepth
-    trenchWidth = trenchDepth / aspectRatio
-    sideWidth = (trenchSpacing - trenchWidth) / 2
+    trenchWidth = old_div(trenchDepth, aspectRatio)
+    sideWidth = old_div((trenchSpacing - trenchWidth), 2)
 
     x, y = mesh.cellCenters
     distanceVar.setValue(1., where=(y > trenchHeight) | ((y > bottomHeight) & (x < xCells * cellSize - sideWidth)))
@@ -275,7 +281,7 @@ def runSimpleTrenchSystem(faradaysConstant=9.6e4,
 
     metalVar.constrain(metalConcentration, mesh.facesTop)
 
-    from surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
+    from .surfactantBulkDiffusionEquation import buildSurfactantBulkDiffusionEquation
     bulkCatalystEquation = buildSurfactantBulkDiffusionEquation(
         bulkVar = bulkCatalystVar,
         distanceVar = distanceVar,
@@ -288,7 +294,7 @@ def runSimpleTrenchSystem(faradaysConstant=9.6e4,
 
     if displayViewers:
         try:
-            from mayaviSurfactantViewer import MayaviSurfactantViewer
+            from .mayaviSurfactantViewer import MayaviSurfactantViewer
             viewer = MayaviSurfactantViewer(distanceVar, catalystVar.interfaceVar, zoomFactor = 1e6, datamax=0.5, datamin=0.0, smooth = 1, title = 'catalyst coverage')
         except:
             viewer = MultiViewer(viewers=(
@@ -324,7 +330,7 @@ def runSimpleTrenchSystem(faradaysConstant=9.6e4,
     try:
         import os
         filepath = os.path.splitext(__file__)[0] + '.gz'
-        print catalystVar.allclose(numerix.loadtxt(filepath), rtol = 1e-4)
+        print(catalystVar.allclose(numerix.loadtxt(filepath), rtol = 1e-4))
     except:
         return 0
 
@@ -332,4 +338,4 @@ __all__ = ["runSimpleTrenchSystem"]
 
 if __name__ == '__main__':
     runSimpleTrenchSystem(numberOfSteps = 800, cellSize = 0.05e-7)
-    raw_input("finished")
+    input("finished")
diff --git a/examples/levelSet/electroChem/trenchMesh.py b/examples/levelSet/electroChem/trenchMesh.py
index 7320efb..586d8fe 100644
--- a/examples/levelSet/electroChem/trenchMesh.py
+++ b/examples/levelSet/electroChem/trenchMesh.py
@@ -33,12 +33,15 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import absolute_import
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
 from fipy.variables.cellVariable import CellVariable
 from fipy.tools import parallelComm
-from gapFillMesh import GapFillMesh
+from .gapFillMesh import GapFillMesh
 
 class TrenchMesh(GapFillMesh):
 
@@ -123,11 +126,11 @@ class TrenchMesh(GapFillMesh):
 
         heightBelowTrench = cellSize * 10.
 
-        heightAboveTrench = trenchDepth / 1.
+        heightAboveTrench = old_div(trenchDepth, 1.)
 
         fineRegionHeight = heightBelowTrench + trenchDepth + heightAboveTrench
         transitionHeight = fineRegionHeight * 3.
-        domainWidth = trenchSpacing / 2.
+        domainWidth = old_div(trenchSpacing, 2.)
         domainHeight = heightBelowTrench + trenchDepth + boundaryLayerDepth
 
         super(TrenchMesh, self).__init__(cellSize=cellSize,
@@ -137,16 +140,16 @@ class TrenchMesh(GapFillMesh):
                                          transitionRegionHeight=transitionHeight,
                                          communicator=parallelComm)
 
-        trenchWidth = trenchDepth / aspectRatio
+        trenchWidth = old_div(trenchDepth, aspectRatio)
 
         x, y = self.cellCenters
-        Y = (y - (heightBelowTrench + trenchDepth / 2))
+        Y = (y - (heightBelowTrench + old_div(trenchDepth, 2)))
         taper = numerix.tan(angle) * Y
         self.electrolyteMask = numerix.where(y > trenchDepth + heightBelowTrench,
                                              1,
                                              numerix.where(y < heightBelowTrench,
                                                            0,
-                                                           numerix.where(x > trenchWidth / 2 + taper,
+                                                           numerix.where(x > old_div(trenchWidth, 2) + taper,
                                                                          0,
                                                                          1)))
     
diff --git a/examples/levelSet/surfactant/circle.py b/examples/levelSet/surfactant/circle.py
index 6b69357..b242e1a 100755
--- a/examples/levelSet/surfactant/circle.py
+++ b/examples/levelSet/surfactant/circle.py
@@ -71,6 +71,11 @@ The result can be tested with the following code:
 0.00813776069241
 
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -80,10 +85,10 @@ nx = 50
 velocity = 1.
 cfl = 0.1
 velocity = 1.
-distanceToTravel = L / 10.
-initialRadius = L / 4.
+distanceToTravel = old_div(L, 10.)
+initialRadius = old_div(L, 4.)
 
-dx = L / nx
+dx = old_div(L, nx)
 timeStepDuration = cfl * dx / velocity
 steps = int(distanceToTravel / dx / cfl)
 
@@ -97,7 +102,7 @@ distanceVariable = DistanceVariable(
     )
 
 x, y = mesh.cellCenters
-cellRadius = numerix.sqrt((x - L / 2.)**2 + (y - L / 2.)**2)
+cellRadius = numerix.sqrt((x - old_div(L, 2.))**2 + (y - old_div(L, 2.))**2)
 distanceVariable.setValue(cellRadius - initialRadius)
 
 initialSurfactantValue =  1.
@@ -121,7 +126,7 @@ if __name__ == '__main__':
     distanceViewer.plot()
     surfactantViewer.plot()
 
-    print 'total surfactant before:', numerix.sum(surfactantVariable * mesh.cellVolumes)
+    print('total surfactant before:', numerix.sum(surfactantVariable * mesh.cellVolumes))
     
     for step in range(steps):
         distanceVariable.updateOld()
@@ -132,7 +137,7 @@ if __name__ == '__main__':
     surfactantEquation.solve(surfactantVariable, dt=1.)
 
 
-    print 'total surfactant after:', numerix.sum(surfactantVariable * mesh.cellVolumes)
+    print('total surfactant after:', numerix.sum(surfactantVariable * mesh.cellVolumes))
 
     areas = (distanceVariable.cellInterfaceAreas < 1e-6) * 1e+10 + distanceVariable.cellInterfaceAreas
     answer = initialSurfactantValue * initialRadius / (initialRadius +  distanceToTravel)
@@ -142,11 +147,11 @@ if __name__ == '__main__':
     size = 0
     for i in range(len(coverage)):
         if coverage[i] > 1e-3:
-            error += (coverage[i] / answer - 1.)**2
+            error += (old_div(coverage[i], answer) - 1.)**2
             size += 1
             
-    error = numerix.sqrt(error / size)
+    error = numerix.sqrt(old_div(error, size))
     
-    print 'error:', error
+    print('error:', error)
     
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/surfactant/expandingCircle.py b/examples/levelSet/surfactant/expandingCircle.py
index 399f142..906f321 100755
--- a/examples/levelSet/surfactant/expandingCircle.py
+++ b/examples/levelSet/surfactant/expandingCircle.py
@@ -88,6 +88,11 @@ Test for the correct position of the interface:
 1
 
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -95,9 +100,9 @@ from fipy import *
 L = 1.
 nx = 50
 cfl = 0.1
-initialRadius = L / 4.
+initialRadius = old_div(L, 4.)
 k = 1
-dx = L / nx
+dx = old_div(L, nx)
 steps = 20
 
 from fipy.tools import serialComm
@@ -107,7 +112,7 @@ x, y = mesh.cellCenters
 distanceVariable = DistanceVariable(
     name = 'level set variable',
     mesh = mesh,
-    value = numerix.sqrt((x - L / 2.)**2 + (y - L / 2.)**2) - initialRadius,
+    value = numerix.sqrt((x - old_div(L, 2.))**2 + (y - old_div(L, 2.))**2) - initialRadius,
     hasOld = 1)
 
 initialSurfactantValue =  1.
@@ -142,7 +147,7 @@ if __name__ == '__main__':
     totalTime = 0
 
     for step in range(steps):
-        print 'step',step
+        print('step',step)
         velocity.setValue(surfactantVariable.interfaceVar * k)
         distanceVariable.extendVariable(velocity)
         timeStepDuration = cfl * dx / velocity.max()
@@ -159,10 +164,10 @@ if __name__ == '__main__':
         finalRadius = numerix.sqrt(2 * k * initialRadius * initialSurfactantValue * totalTime + initialRadius**2)
         answer = initialSurfactantValue * initialRadius / finalRadius
         coverage = surfactantVariable.interfaceVar
-        error = (coverage / answer - 1)**2 * (coverage > 1e-3)
-        print 'error', numerix.sqrt(numerix.sum(error) / numerix.sum(error > 0))
+        error = (old_div(coverage, answer) - 1)**2 * (coverage > 1e-3)
+        print('error', numerix.sqrt(old_div(numerix.sum(error), numerix.sum(error > 0))))
 
 
         
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/levelSet/surfactant/square.py b/examples/levelSet/surfactant/square.py
index 1a975ef..173e8e8 100755
--- a/examples/levelSet/surfactant/square.py
+++ b/examples/levelSet/surfactant/square.py
@@ -51,6 +51,11 @@ Advect the interface and check the position.
 
    
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -59,11 +64,11 @@ L = 1.
 dx = 0.1
 velocity = 1.
 cfl = 0.1
-distanceToTravel = L / 5.
+distanceToTravel = old_div(L, 5.)
 boxSize = .2
 
-nx = int(L / dx)
-ny = int(L / dx)
+nx = int(old_div(L, dx))
+ny = int(old_div(L, dx))
 
 steps = int(distanceToTravel / dx / cfl)
 
@@ -71,8 +76,8 @@ timeStepDuration = cfl * dx / velocity
 
 mesh = Grid2D(dx = dx, dy = dx, nx = nx, ny = ny)
 
-x0 = (L - boxSize) / 2
-x1 = (L + boxSize) / 2
+x0 = old_div((L - boxSize), 2)
+x1 = old_div((L + boxSize), 2)
 
 distanceVariable = DistanceVariable(
     mesh = mesh,
@@ -106,7 +111,7 @@ if __name__ == '__main__':
     distanceVariable.calcDistanceFunction()
 
     for step in range(steps):
-        print numerix.sum(surfactantVariable)
+        print(numerix.sum(surfactantVariable))
         distanceVariable.updateOld()
         surfactantEquation.solve(surfactantVariable, dt=1)
         advectionEquation.solve(distanceVariable, dt = timeStepDuration)
@@ -117,5 +122,5 @@ if __name__ == '__main__':
 
     distanceViewer.plot()
     surfactantViewer.plot()
-    print surfactantVariable
-    raw_input('finished')
+    print(surfactantVariable)
+    input('finished')
diff --git a/examples/meshing/gmshRefinement.py b/examples/meshing/gmshRefinement.py
index 81a75ca..cd000f7 100644
--- a/examples/meshing/gmshRefinement.py
+++ b/examples/meshing/gmshRefinement.py
@@ -1,3 +1,7 @@
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 from fipy import *
 
 from matplotlib import cm
@@ -72,12 +76,12 @@ for refinement in range(10):
     res1 = L2norm(res)
     res1a = CellVariable(mesh=mesh, value=abs(res))
     
-    res = CellVariable(mesh=mesh, name="residual", value=abs(res) / mesh.cellVolumes**(1./mesh.dim) / 1e-3)
+    res = CellVariable(mesh=mesh, name="residual", value=abs(res) / mesh.cellVolumes**(old_div(1.,mesh.dim)) / 1e-3)
     
     # want cells no bigger than 1 and no smaller than 0.001
     maxSize = 1.
     minSize = 0.001
-    monitor = CellVariable(mesh=mesh, name="monitor", value= 1. / (res + maxSize) +  minSize)
+    monitor = CellVariable(mesh=mesh, name="monitor", value= old_div(1., (res + maxSize)) +  minSize)
 
     viewer = Viewer(vars=potential, xmin=3.5, xmax=4.5, ymin=3.5, ymax=4.5)
 #     viewer = Viewer(vars=(potential, charge))
@@ -86,7 +90,7 @@ for refinement in range(10):
 #     resviewer = Viewer(vars=res1a, log=True, datamin=1e-6, datamax=1e-2, cmap=cm.gray)
 #     monviewer = Viewer(vars=monitor, log=True, datamin=1e-3, datamax=1)
  
-    raw_input("refinement %d, res0: %g, res: %g:%g, N: %d, min: %g, max: %g, avg: %g" 
+    input("refinement %d, res0: %g, res: %g:%g, N: %d, min: %g, max: %g, avg: %g" 
               % (refinement, res0, res1, res1a.cellVolumeAverage, mesh.numberOfCells, sqrt(min(mesh.cellVolumes)), sqrt(max(mesh.cellVolumes)), mean(sqrt(mesh.cellVolumes))))
     
     
\ No newline at end of file
diff --git a/examples/meshing/inputGrid2D.py b/examples/meshing/inputGrid2D.py
index 4220b09..9228d23 100755
--- a/examples/meshing/inputGrid2D.py
+++ b/examples/meshing/inputGrid2D.py
@@ -83,6 +83,7 @@ One can view the mesh with the following code,
    ...     viewer.plot()
    
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 def _run():
@@ -91,4 +92,4 @@ def _run():
     
 if __name__ == '__main__':
     _run()
-    raw_input("finished")
+    input("finished")
diff --git a/examples/meshing/sphere.py b/examples/meshing/sphere.py
index 60412e5..42d7916 100644
--- a/examples/meshing/sphere.py
+++ b/examples/meshing/sphere.py
@@ -82,12 +82,13 @@ demonstrates how to create the required mesh.
    True
    
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
 
diff --git a/examples/parallel.py b/examples/parallel.py
index 31ec78f..7e9339d 100644
--- a/examples/parallel.py
+++ b/examples/parallel.py
@@ -1,3 +1,4 @@
+from __future__ import print_function
 from mpi4py import MPI
 
 m4comm = MPI.COMM_WORLD
@@ -19,5 +20,5 @@ fipy_info = "FiPy: %d cells on processor %d of %d" % (mesh.numberOfCells,
                                                       parallelComm.procID,
                                                       parallelComm.Nproc)
                                                       
-print " :: ".join((mpi4py_info, trilinos_info, fipy_info))
+print(" :: ".join((mpi4py_info, trilinos_info, fipy_info)))
 
diff --git a/examples/phase/anisotropy.py b/examples/phase/anisotropy.py
index 2ce3e40..9144661 100755
--- a/examples/phase/anisotropy.py
+++ b/examples/phase/anisotropy.py
@@ -234,11 +234,12 @@ We note that this FiPy simulation is written in about 50 lines of code (excludin
 custom viewer), compared with over 800 lines of (fairly lucid) FORTRAN code used for
 the figures in :cite:`WarrenPolycrystal`.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/anisotropyOLD.py b/examples/phase/anisotropyOLD.py
index 6525e16..b7ad04e 100755
--- a/examples/phase/anisotropyOLD.py
+++ b/examples/phase/anisotropyOLD.py
@@ -228,11 +228,12 @@ the data and compares it with the `phase` variable.
 >>> print phase.allclose(testData)
 1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/impingement/mesh20x20.py b/examples/phase/impingement/mesh20x20.py
index a33162f..5e75be2 100755
--- a/examples/phase/impingement/mesh20x20.py
+++ b/examples/phase/impingement/mesh20x20.py
@@ -270,11 +270,12 @@ The solution is compared against Ryo Kobayashi's test data
 >>> print newTheta.allclose(testData, rtol=1e-7)
 1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
     
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/impingement/mesh40x1.py b/examples/phase/impingement/mesh40x1.py
index 4e4e714..db733b5 100755
--- a/examples/phase/impingement/mesh40x1.py
+++ b/examples/phase/impingement/mesh40x1.py
@@ -235,10 +235,11 @@ extracts the data and compares it with the ``theta`` variable.
 >>> print theta.allclose(testData)
 1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/phase/missOrientation/circle.py b/examples/phase/missOrientation/circle.py
index 33f4c63..ee3f6a8 100755
--- a/examples/phase/missOrientation/circle.py
+++ b/examples/phase/missOrientation/circle.py
@@ -87,6 +87,10 @@ data and compares it with the ``phase`` variable.
 1
 
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -106,8 +110,8 @@ epsilon = 0.008
 s = 0.01
 alpha = 0.015
       
-dx = L / nx
-dy = L / ny
+dx = old_div(L, nx)
+dy = old_div(L, ny)
 
 mesh = Grid2D(dx, dy, nx, ny)
 
@@ -115,7 +119,7 @@ phase = CellVariable(name = 'PhaseField', mesh = mesh, value = 1.)
 
 theta = ModularVariable(name = 'Theta', mesh = mesh, value = 1.)
 x, y = mesh.cellCenters
-theta.setValue(0., where=(x - L / 2.)**2 + (y - L / 2.)**2 < (L / 4.)**2)
+theta.setValue(0., where=(x - old_div(L, 2.))**2 + (y - old_div(L, 2.))**2 < (old_div(L, 4.))**2)
 
 mPhiVar = phase - 0.5 + temperature * phase * (1 - phase)
 thetaMag = theta.old.grad.mag
@@ -134,4 +138,4 @@ if __name__ == '__main__':
     for step in range(steps):
         phaseEq.solve(phase, dt = timeStepDuration)
         phaseViewer.plot()
-    raw_input('finished')
+    input('finished')
diff --git a/examples/phase/missOrientation/mesh1D.py b/examples/phase/missOrientation/mesh1D.py
index 24fed57..6adf71a 100755
--- a/examples/phase/missOrientation/mesh1D.py
+++ b/examples/phase/missOrientation/mesh1D.py
@@ -85,6 +85,10 @@ data and compares it with the ``theta`` variable.
 >>> print phase.allclose(testData)
 1
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy import *
@@ -100,14 +104,14 @@ s = 0.01
 alpha = 0.015
 temperature = 1.
 
-dx = L / nx
+dx = old_div(L, nx)
 
 mesh = Grid1D(dx = dx, nx = nx)
 
 phase = CellVariable(name = 'PhaseField', mesh = mesh, value = 1.)
 
 theta = ModularVariable(name = 'Theta', mesh = mesh, value = 1.)
-theta.setValue(0., where=mesh.cellCenters[0] > L / 2.)
+theta.setValue(0., where=mesh.cellCenters[0] > old_div(L, 2.))
 
 mPhiVar = phase - 0.5 + temperature * phase * (1 - phase)
 thetaMag = theta.old.grad.mag
@@ -126,4 +130,4 @@ if __name__ == '__main__':
    for step in range(steps):
       phaseEq.solve(phase, dt = timeStepDuration)
       phaseViewer.plot()
-   raw_input('finished')
+   input('finished')
diff --git a/examples/phase/missOrientation/modCircle.py b/examples/phase/missOrientation/modCircle.py
index 1e5a9b8..0bbd173 100755
--- a/examples/phase/missOrientation/modCircle.py
+++ b/examples/phase/missOrientation/modCircle.py
@@ -86,6 +86,10 @@ data and compares it with the ``phase`` variable.
 1
 
 """
+from __future__ import division
+from builtins import input
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 
@@ -106,8 +110,8 @@ epsilon = 0.008
 s = 0.01
 alpha = 0.015
 
-dx = L / nx
-dy = L / ny
+dx = old_div(L, nx)
+dy = old_div(L, ny)
 
 mesh = Grid2D(dx, dy, nx, ny)
 
@@ -115,7 +119,7 @@ phase = CellVariable(name = 'PhaseField', mesh = mesh, value = 1.)
 
 theta = ModularVariable(name = 'Theta', mesh = mesh, value = 2. * numerix.pi / 3.)
 x, y = mesh.cellCenters
-theta.setValue(-2. * numerix.pi / 3., where=(x - L / 2.)**2 + (y - L / 2.)**2 < (L / 4.)**2) 
+theta.setValue(-2. * numerix.pi / 3., where=(x - old_div(L, 2.))**2 + (y - old_div(L, 2.))**2 < (old_div(L, 4.))**2) 
 
 mPhiVar = phase - 0.5 + temperature * phase * (1 - phase)
 thetaMag = theta.old.grad.mag
@@ -134,4 +138,4 @@ if __name__ == '__main__':
    for step in range(steps):
       phaseEq.solve(phase, dt = timeStepDuration)
       phaseViewer.plot()
-   raw_input('finished')
+   input('finished')
diff --git a/examples/phase/polyxtal.py b/examples/phase/polyxtal.py
index 484dd9e..4221f30 100755
--- a/examples/phase/polyxtal.py
+++ b/examples/phase/polyxtal.py
@@ -366,11 +366,12 @@ The non-uniform temperature results from the release of latent
 heat at the solidifying interface. The dendrite arms grow fastest 
 where the temperature gradient is steepest.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/polyxtalCoupled.py b/examples/phase/polyxtalCoupled.py
index 7618645..af724a9 100755
--- a/examples/phase/polyxtalCoupled.py
+++ b/examples/phase/polyxtalCoupled.py
@@ -367,11 +367,12 @@ The non-uniform temperature results from the release of latent
 heat at the solidifying interface. The dendrite arms grow fastest 
 where the temperature gradient is steepest.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/quaternary.py b/examples/phase/quaternary.py
index 8aab6de..adb03e6 100755
--- a/examples/phase/quaternary.py
+++ b/examples/phase/quaternary.py
@@ -430,12 +430,13 @@ True
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == "__main__": 
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
 
 ## if __name__ == '__main__':
 ##     ## from fipy.tools.profiler.profiler import Profiler
diff --git a/examples/phase/simple.py b/examples/phase/simple.py
index b2f0a47..7647f63 100755
--- a/examples/phase/simple.py
+++ b/examples/phase/simple.py
@@ -511,6 +511,7 @@ True
 .. .. bibmissing:: /documentation/refs.bib
     :sort:
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 
@@ -518,5 +519,5 @@ if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
 
diff --git a/examples/phase/symmetry.py b/examples/phase/symmetry.py
index c7352e0..0051a77 100755
--- a/examples/phase/symmetry.py
+++ b/examples/phase/symmetry.py
@@ -111,12 +111,13 @@ The following code tests the results with a different algorithm:
 >>> numerix.allclose(testResult,topRight, atol = 1e-10)
 1
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
-    raw_input("finished")
+    input("finished")
 
     
 
diff --git a/examples/riemann/acoustics.py b/examples/riemann/acoustics.py
index f16270f..96a8925 100644
--- a/examples/riemann/acoustics.py
+++ b/examples/riemann/acoustics.py
@@ -39,6 +39,11 @@ Test
 True
 
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import input
+from builtins import range
+from past.utils import old_div
 
 __docformat__ = 'restructuredtext'
 
@@ -51,7 +56,7 @@ cfl = 0.1
 K = 4.
 rho = 1.
 
-dx = L / nx
+dx = old_div(L, nx)
 m = Grid1D(nx=nx, dx=dx) + X0
 x, = m.cellCenters
 
@@ -60,7 +65,7 @@ q = CellVariable(mesh=m, rank=1, elementshape=(2,))
 q[0,:] = numerix.exp(-50 * (x - 0.3)**2) * numerix.cos(20 * (x - 0.3))
 q[0, x > 0.3] = 0.
 
-Ax = FaceVariable(mesh=m, rank=3, value=[((0, K), (1 / rho, 0))], elementshape=(1, 2, 2))
+Ax = FaceVariable(mesh=m, rank=3, value=[((0, K), (old_div(1, rho), 0))], elementshape=(1, 2, 2))
 
 eqn = TransientTerm() + CentralDifferenceConvectionTerm(Ax) == 0
 
@@ -68,16 +73,16 @@ if  __name__ == '__main__':
     from fipy import MatplotlibViewer as Viewer
     vi = Viewer((q[0], q[1]))
     vi.plot()
-    raw_input('press key')
+    input('press key')
     
 for step in range(500):
     eqn.solve(q, dt=cfl * dx)
     if step % 10 ==  0 and  __name__ == '__main__':
-        print 'step',step
+        print('step',step)
         vi.plot()
 
 if __name__ == '__main__':
     import fipy.tests.doctestPlus
     exec(fipy.tests.doctestPlus._getScript())
 
-    raw_input('finished')
+    input('finished')
diff --git a/examples/updating/update0_1to1_0.py b/examples/updating/update0_1to1_0.py
index 34210dd..14cd642 100755
--- a/examples/updating/update0_1to1_0.py
+++ b/examples/updating/update0_1to1_0.py
@@ -318,6 +318,7 @@ appropriate for the supplied `Variable` object(s):
 Please do not hesitate to contact us if this example does not help you
 convert your existing scripts to :term:`FiPy` 1.0.
 """
+from builtins import input
 __docformat__ = 'restructuredtext'
 
 def _test(): 
@@ -326,4 +327,4 @@ def _test():
     
 if __name__ == "__main__": 
     _test() 
-    raw_input('finished')
+    input('finished')
diff --git a/ez_setup.py b/ez_setup.py
index 1ff1d3e..6c42784 100644
--- a/ez_setup.py
+++ b/ez_setup.py
@@ -13,6 +13,9 @@ the appropriate options to ``use_setuptools()``.
 
 This file can also be run as a script to install or upgrade setuptools.
 """
+from __future__ import print_function
+from future import standard_library
+standard_library.install_aliases()
 import sys
 DEFAULT_VERSION = "0.6c11"
 DEFAULT_URL     = "http://pypi.python.org/packages/%s/s/setuptools/" % sys.version[:3]
@@ -70,10 +73,10 @@ def _validate_md5(egg_name, data):
     if egg_name in md5_data:
         digest = md5(data).hexdigest()
         if digest != md5_data[egg_name]:
-            print >>sys.stderr, (
+            print((
                 "md5 validation of %s failed!  (Possible download problem?)"
                 % egg_name
-            )
+            ), file=sys.stderr)
             sys.exit(2)
     return data
 
@@ -103,14 +106,14 @@ def use_setuptools(
         return do_download()       
     try:
         pkg_resources.require("setuptools>="+version); return
-    except pkg_resources.VersionConflict, e:
+    except pkg_resources.VersionConflict as e:
         if was_imported:
-            print >>sys.stderr, (
+            print((
             "The required version of setuptools (>=%s) is not available, and\n"
             "can't be installed while this script is running. Please install\n"
             " a more recent version first, using 'easy_install -U setuptools'."
             "\n\n(Currently using %r)"
-            ) % (version, e.args[0])
+            ) % (version, e.args[0]), file=sys.stderr)
             sys.exit(2)
         else:
             del pkg_resources, sys.modules['pkg_resources']    # reload ok
@@ -129,7 +132,7 @@ def download_setuptools(
     with a '/'). `to_dir` is the directory where the egg will be downloaded.
     `delay` is the number of seconds to pause before an actual download attempt.
     """
-    import urllib2, shutil
+    import urllib.request, urllib.error, urllib.parse, shutil
     egg_name = "setuptools-%s-py%s.egg" % (version,sys.version[:3])
     url = download_base + egg_name
     saveto = os.path.join(to_dir, egg_name)
@@ -155,7 +158,7 @@ and place it in this directory before rerunning this script.)
                     version, download_base, delay, url
                 ); from time import sleep; sleep(delay)
             log.warn("Downloading %s", url)
-            src = urllib2.urlopen(url)
+            src = urllib.request.urlopen(url)
             # Read/write all in one block, so we don't create a corrupt file
             # if the download is interrupted.
             data = _validate_md5(egg_name, src.read())
@@ -216,10 +219,10 @@ def main(argv, version=DEFAULT_VERSION):
                 os.unlink(egg)
     else:
         if setuptools.__version__ == '0.0.1':
-            print >>sys.stderr, (
+            print((
             "You have an obsolete version of setuptools installed.  Please\n"
             "remove it from your system entirely before rerunning this script."
-            )
+            ), file=sys.stderr)
             sys.exit(2)
 
     req = "setuptools>="+version
@@ -238,8 +241,8 @@ def main(argv, version=DEFAULT_VERSION):
             from setuptools.command.easy_install import main
             main(argv)
         else:
-            print "Setuptools version",version,"or greater has been installed."
-            print '(Run "ez_setup.py -U setuptools" to reinstall or upgrade.)'
+            print("Setuptools version",version,"or greater has been installed.")
+            print('(Run "ez_setup.py -U setuptools" to reinstall or upgrade.)')
 
 def update_md5(filenames):
     """Update our built-in md5 registry"""
@@ -252,7 +255,7 @@ def update_md5(filenames):
         md5_data[base] = md5(f.read()).hexdigest()
         f.close()
 
-    data = ["    %r: %r,\n" % it for it in md5_data.items()]
+    data = ["    %r: %r,\n" % it for it in list(md5_data.items())]
     data.sort()
     repl = "".join(data)
 
@@ -262,7 +265,7 @@ def update_md5(filenames):
 
     match = re.search("\nmd5_data = {\n([^}]+)}", src)
     if not match:
-        print >>sys.stderr, "Internal error!"
+        print("Internal error!", file=sys.stderr)
         sys.exit(2)
 
     src = src[:match.start(1)] + repl + src[match.end(1):]
diff --git a/fipy/__init__.py b/fipy/__init__.py
index 5eafee8..91c64a5 100644
--- a/fipy/__init__.py
+++ b/fipy/__init__.py
@@ -162,7 +162,7 @@ def test(*args):
               script_args = ['egg_info', '--egg-base=' + tmpDir,
                              'test', '--modules'] + list(args),
               cmdclass={'test': _TestClass(_test)})
-    except SystemExit, exitErr:
+    except SystemExit as exitErr:
         import shutil
         shutil.rmtree(tmpDir)
         raise exitErr
diff --git a/fipy/boundaryConditions/boundaryCondition.py b/fipy/boundaryConditions/boundaryCondition.py
index 3997c52..4f3aac1 100644
--- a/fipy/boundaryConditions/boundaryCondition.py
+++ b/fipy/boundaryConditions/boundaryCondition.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -54,7 +55,7 @@ class BoundaryCondition(object):
             - `value`: The value to impose.
         """
         if self.__class__ is BoundaryCondition:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
         
         self.faces = faces
         if not (isinstance(value, PhysicalField) or isinstance(value, Variable)):
@@ -63,7 +64,7 @@ class BoundaryCondition(object):
         
         if not (self.faces | self.faces.mesh.exteriorFaces 
                 == self.faces.mesh.exteriorFaces).value.all():
-            raise IndexError, 'Face list has interior faces'
+            raise IndexError('Face list has interior faces')
         
         self.adjacentCellIDs = self.faces.mesh._adjacentCellIDs[0][self.faces.value]
         self.boundaryConditionApplied = False
@@ -95,7 +96,7 @@ class BoundaryCondition(object):
             return None
 
     def __repr__(self):
-        return "%s(faces = %s, value = %s)" % (self.__class__.__name__, `self.faces`, `self.value`)
+        return "%s(faces = %s, value = %s)" % (self.__class__.__name__, repr(self.faces), repr(self.value))
 
     def _resetBoundaryConditionApplied(self):
         self.boundaryConditionApplied = False
diff --git a/fipy/boundaryConditions/constraint.py b/fipy/boundaryConditions/constraint.py
index 27e559e..b1e16e8 100644
--- a/fipy/boundaryConditions/constraint.py
+++ b/fipy/boundaryConditions/constraint.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/matrices/pysparseMatrix.py b/fipy/matrices/pysparseMatrix.py
index c8b3f1f..6f97127 100644
--- a/fipy/matrices/pysparseMatrix.py
+++ b/fipy/matrices/pysparseMatrix.py
@@ -32,6 +32,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -182,7 +185,7 @@ class _PysparseMatrix(_SparseMatrix):
 
     @property
     def _range(self):
-        return range(self._shape[1]), range(self._shape[0])
+        return list(range(self._shape[1])), list(range(self._shape[0]))
         
     def put(self, vector, id1, id2):
         """
@@ -341,7 +344,7 @@ class _PysparseMeshMatrix(_PysparseMatrixFromShape):
             if A.shape[0] == 0:
                 bandwidth = 0
             else:
-                bandwidth = int(numerix.ceil(float(len(values)) / float(A.shape[0])))
+                bandwidth = int(numerix.ceil(old_div(float(len(values)), float(A.shape[0]))))
             bandwidth = 1
             from fipy.matrices.trilinosMatrix import _TrilinosMeshMatrixKeepStencil
             self.trilinosMatrix = _TrilinosMeshMatrixKeepStencil(mesh=self.mesh, bandwidth=bandwidth, 
diff --git a/fipy/matrices/scipyMatrix.py b/fipy/matrices/scipyMatrix.py
index 23e3942..6f89fc0 100644
--- a/fipy/matrices/scipyMatrix.py
+++ b/fipy/matrices/scipyMatrix.py
@@ -1,3 +1,4 @@
+from builtins import range
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -190,7 +191,7 @@ class _ScipyMatrix(_SparseMatrix):
 
     @property
     def _range(self):
-        return range(self._shape[1]), range(self._shape[0])
+        return list(range(self._shape[1])), list(range(self._shape[0]))
         
     def put(self, vector, id1, id2):
         """
diff --git a/fipy/matrices/sparseMatrix.py b/fipy/matrices/sparseMatrix.py
index 508d5e5..75d0792 100644
--- a/fipy/matrices/sparseMatrix.py
+++ b/fipy/matrices/sparseMatrix.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/matrices/test.py b/fipy/matrices/test.py
index cf2e40b..3a14535 100755
--- a/fipy/matrices/test.py
+++ b/fipy/matrices/test.py
@@ -47,7 +47,7 @@ elif solver == 'scipy' or solver == 'pyamg':
 elif solver == 'pysparse':
     docTestModuleNames = ('pysparseMatrix',)
 else:
-    raise ImportError, 'Unknown solver package %s' % solver
+    raise ImportError('Unknown solver package %s' % solver)
 
 def _suite():
     return _LateImportDocTestSuite(docTestModuleNames=docTestModuleNames, base=__name__)
diff --git a/fipy/matrices/trilinosMatrix.py b/fipy/matrices/trilinosMatrix.py
index 5b3523b..96a45b2 100644
--- a/fipy/matrices/trilinosMatrix.py
+++ b/fipy/matrices/trilinosMatrix.py
@@ -33,6 +33,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -116,7 +120,7 @@ class _TrilinosMatrix(_SparseMatrix):
 
     @property
     def _range(self):
-        return (range(self.rowMap.NumGlobalElements()), self.rowMap.MyGlobalElements())
+        return (list(range(self.rowMap.NumGlobalElements())), self.rowMap.MyGlobalElements())
 
     def __setitem__(self, index, value):
         self.matrix[index] = value
@@ -141,8 +145,7 @@ class _TrilinosMatrix(_SparseMatrix):
             # Depending on which one is more filled, pick the order of operations 
             if self.matrix.Filled() and other.matrix.NumGlobalNonzeros() \
                                             > self.matrix.NumGlobalNonzeros():
-                tempBandwidth = other.matrix.NumGlobalNonzeros() \
-                                 /self.matrix.NumGlobalRows()+1
+                tempBandwidth = old_div(other.matrix.NumGlobalNonzeros(),self.matrix.NumGlobalRows())+1
 
                 tempMatrix = Epetra.CrsMatrix(Epetra.Copy, self.rowMap, tempBandwidth)
                 
@@ -542,7 +545,7 @@ class _TrilinosMatrixFromShape(_TrilinosMatrix):
         """
         size = max(rows, cols)
         if sizeHint is not None and bandwidth == 0:
-            bandwidth = (sizeHint + size - 1) / (size or 1) 
+            bandwidth = old_div((sizeHint + size - 1), (size or 1)) 
         else:
             bandwidth = bandwidth
             
@@ -552,12 +555,12 @@ class _TrilinosMatrixFromShape(_TrilinosMatrix):
             # Matrix building gets done on one processor - it gets the map for
             # all the rows
             if comm.MyPID() == 0:
-                rowMap = Epetra.Map(rows, range(0, rows), 0, comm)
+                rowMap = Epetra.Map(rows, list(range(0, rows)), 0, comm)
             else: 
                 rowMap = Epetra.Map(rows, [], 0, comm)
 
         if colMap is None:
-           colMap = Epetra.Map(cols, range(0, cols), 0, comm)
+           colMap = Epetra.Map(cols, list(range(0, cols)), 0, comm)
 
         matrix = Epetra.CrsMatrix(Epetra.Copy, rowMap, (bandwidth*3)//2)
 
@@ -636,7 +639,7 @@ class _TrilinosMeshMatrix(_TrilinosMatrixFromShape):
 
     @property
     def _globalCommonColIDs(self):
-        return range(0, self.numberOfVariables, self.mesh.globalNumberOfCells)
+        return list(range(0, self.numberOfVariables, self.mesh.globalNumberOfCells))
                      
     @property
     def _globalOverlappingColIDs(self):
diff --git a/fipy/meshes/abstractMesh.py b/fipy/meshes/abstractMesh.py
index aa0a0e7..e7cc9fc 100644
--- a/fipy/meshes/abstractMesh.py
+++ b/fipy/meshes/abstractMesh.py
@@ -33,6 +33,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = ["AbstractMesh"]
@@ -165,7 +169,7 @@ class AbstractMesh(object):
         if self.dim > 1:
             return self.cellCenters[1]
         else:
-            raise AttributeError, '1D meshes do not have a "y" attribute.'
+            raise AttributeError('1D meshes do not have a "y" attribute.')
 
     @property
     def z(self):
@@ -183,7 +187,7 @@ class AbstractMesh(object):
         if self.dim > 2:
             return self.cellCenters[2]
         else:
-            raise AttributeError, '1D and 2D meshes do not have a "z" attribute.'
+            raise AttributeError('1D and 2D meshes do not have a "z" attribute.')
             
     @property
     def extents(self):
@@ -326,7 +330,7 @@ class AbstractMesh(object):
         otherNumVertices = otherc.vertexCoords.shape[-1]
         ## check dimensions
         if(selfc.vertexCoords.shape[0] != otherc.vertexCoords.shape[0]):
-            raise MeshAdditionError, "Dimensions do not match"
+            raise MeshAdditionError("Dimensions do not match")
             
         ## compute vertex correlates
 
@@ -838,7 +842,7 @@ class AbstractMesh(object):
 
     @property
     def _cellDistanceNormals(self):
-        return self._cellDistanceNormals/ self._cellDistances
+        return old_div(self._cellDistanceNormals, self._cellDistances)
      
     @property
     def _cellAreaProjections(self):
@@ -973,7 +977,7 @@ class AbstractMesh(object):
         
         """
         if isinstance(other, AbstractMesh):
-            raise TypeError, "'-' is unsupported for meshes, use '+'"
+            raise TypeError("'-' is unsupported for meshes, use '+'")
         else:
             return self._translate(-numerix.array(other))
 
@@ -989,7 +993,7 @@ class AbstractMesh(object):
         NotImplementedError
         
         """
-        return self.__mul__(1 / other)
+        return self.__mul__(old_div(1, other))
         
     __div__ = __truediv__
     
@@ -1006,7 +1010,7 @@ class AbstractMesh(object):
     def _VTKCellType(self):
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
         return tvtk.ConvexPointSet().cell_type
                 
@@ -1025,7 +1029,7 @@ class AbstractMesh(object):
         
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
         num = counts.shape[0]
 
@@ -1051,7 +1055,7 @@ class AbstractMesh(object):
         """
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
         
         points = self.faceCenters
@@ -1150,7 +1154,7 @@ class AbstractMesh(object):
             xCoords = numerix.take(self.vertexCoords[0], vertexIDs)
             yCoords = numerix.take(self.vertexCoords[1], vertexIDs)
 
-            return float((yCoords.max() - yCoords.min()) / (xCoords.max() - xCoords.min()))
+            return float(old_div((yCoords.max() - yCoords.min()), (xCoords.max() - xCoords.min())))
 
      
 def _madmin(x):
diff --git a/fipy/meshes/builders/abstractGridBuilder.py b/fipy/meshes/builders/abstractGridBuilder.py
index 035102e..93cbd51 100644
--- a/fipy/meshes/builders/abstractGridBuilder.py
+++ b/fipy/meshes/builders/abstractGridBuilder.py
@@ -1,3 +1,7 @@
+from builtins import zip
+from builtins import range
+from builtins import object
+from functools import reduce
 #!/usr/bin/env python
 
 ## 
@@ -144,10 +148,10 @@ class _AbstractGridBuilder(object):
         else:
             spatialNums = [n + 1 for n in newNs]
 
-        spatialDict = dict(zip(["numVerticalCols",
+        spatialDict = dict(list(zip(["numVerticalCols",
                                 "numHorizontalRows",
                                 "numLayersDeep"][:len(spatialNums)],
-                               spatialNums))
+                               spatialNums)))
 
         numVertices = reduce(self._mult, spatialNums)
         numCells = reduce(self._mult, newNs)
@@ -246,7 +250,7 @@ class _AbstractGridBuilder(object):
         # `permutations` is the cleanest way to do this, but it's new in 
         # python 2.6, so we can't rely on it.
         if hasattr(itertools, "permutations"):
-            nIter = list(itertools.permutations(range(len(ns))))
+            nIter = list(itertools.permutations(list(range(len(ns)))))
 
             # ensure len(nIter) == len(ns) && nIter[i][0] unique
             if len(ns) == 3: 
diff --git a/fipy/meshes/builders/utilityClasses.py b/fipy/meshes/builders/utilityClasses.py
index 5a30161..5c86bba 100644
--- a/fipy/meshes/builders/utilityClasses.py
+++ b/fipy/meshes/builders/utilityClasses.py
@@ -1,3 +1,6 @@
+from builtins import zip
+from builtins import range
+from builtins import object
 #!/usr/bin/env python
 
 ## 
@@ -84,7 +87,7 @@ class _DOffsets(object):
         if type(offset) in [int, float]:
             offset = [offset]
 
-        for d, n, i in zip(ds, ns, range(len(ds))):
+        for d, n, i in zip(ds, ns, list(range(len(ds)))):
             if numerix.getShape(d) is not ():
                 offsetList.append(numerix.sum(d[0:offset[i]]))
                 newDs.append(d[offset[i]:offset[i] + n])
@@ -144,7 +147,7 @@ class _NonuniformNumPts(_AbstractNumPts):
         else:
             n = int(n or len(d))
             if n != len(d) and len(d) != 1:
-                raise IndexError, "n%s != len(d%s)" % (axis, axis)
+                raise IndexError("n%s != len(d%s)" % (axis, axis))
                 
         return n
 
@@ -155,7 +158,7 @@ class _UniformNumPts(_AbstractNumPts):
  
     @staticmethod
     def calcNs(ns, ds):
-        return map(lambda x: int(x), ns)
+        return [int(x) for x in ns]
 
 if __name__ == '__main__':
     import doctest
diff --git a/fipy/meshes/cylindricalNonUniformGrid1D.py b/fipy/meshes/cylindricalNonUniformGrid1D.py
index 8c05182..9cdf22c 100644
--- a/fipy/meshes/cylindricalNonUniformGrid1D.py
+++ b/fipy/meshes/cylindricalNonUniformGrid1D.py
@@ -35,6 +35,8 @@
 """
 1D Mesh
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -95,7 +97,7 @@ class CylindricalNonUniformGrid1D(NonUniformGrid1D):
         return self._calcFaceCenters()[0]
 
     def _calcCellVolumes(self):
-        return super(CylindricalNonUniformGrid1D, self)._calcCellVolumes() / 2.   
+        return old_div(super(CylindricalNonUniformGrid1D, self)._calcCellVolumes(), 2.)   
 
     def _translate(self, vector):
         return CylindricalNonUniformGrid1D(dx=self.args['dx'], nx=self.args['nx'], 
diff --git a/fipy/meshes/cylindricalUniformGrid1D.py b/fipy/meshes/cylindricalUniformGrid1D.py
index 45fb93f..87c3f27 100644
--- a/fipy/meshes/cylindricalUniformGrid1D.py
+++ b/fipy/meshes/cylindricalUniformGrid1D.py
@@ -35,6 +35,8 @@
 """
 1D Mesh
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.meshes.uniformGrid1D import UniformGrid1D
@@ -76,7 +78,7 @@ class CylindricalUniformGrid1D(UniformGrid1D):
  
     @property
     def _faceAspectRatios(self):
-        return self._faceAreas / self._cellDistances
+        return old_div(self._faceAreas, self._cellDistances)
     
     @property
     def _areaProjections(self):
diff --git a/fipy/meshes/cylindricalUniformGrid2D.py b/fipy/meshes/cylindricalUniformGrid2D.py
index 5f1a19e..f540e43 100644
--- a/fipy/meshes/cylindricalUniformGrid2D.py
+++ b/fipy/meshes/cylindricalUniformGrid2D.py
@@ -35,6 +35,8 @@
 """
 2D cylindrical rectangular Mesh with constant spacing in x and constant spacing in y
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.meshes.uniformGrid2D import UniformGrid2D
@@ -76,9 +78,9 @@ class CylindricalUniformGrid2D(UniformGrid2D):
     def _cellAreas(self):
         areas = numerix.ones((4, self.numberOfCells), 'd')
         areas[0] = self.dx * self._cellCenters[0]
-        areas[1] = self.dy * (self._cellCenters[0] + self.dx / 2)
+        areas[1] = self.dy * (self._cellCenters[0] + old_div(self.dx, 2))
         areas[2] = self.dx * self._cellCenters[0]
-        areas[3] = self.dy * (self._cellCenters[0] - self.dx / 2)
+        areas[3] = self.dy * (self._cellCenters[0] - old_div(self.dx, 2))
         return areas
  
     """
diff --git a/fipy/meshes/factoryMeshes.py b/fipy/meshes/factoryMeshes.py
index 3109c53..c8935f7 100644
--- a/fipy/meshes/factoryMeshes.py
+++ b/fipy/meshes/factoryMeshes.py
@@ -37,6 +37,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import parallelComm
@@ -73,8 +75,8 @@ def _dnl(dx, nx, Lx):
             nx = 1
     else:
         if nx is None:
-            nx = int(Lx / dx) or 1
-        dx = Lx / int(nx)
+            nx = int(old_div(Lx, dx)) or 1
+        dx = old_div(Lx, int(nx))
 
     return dx, int(nx)
 
diff --git a/fipy/meshes/gmshMesh.py b/fipy/meshes/gmshMesh.py
index 1f08221..b6429fa 100755
--- a/fipy/meshes/gmshMesh.py
+++ b/fipy/meshes/gmshMesh.py
@@ -37,6 +37,13 @@
 # ###################################################################
 ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import zip
+from builtins import str
+from builtins import range
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -80,7 +87,7 @@ register_skipper(flag="GMSH",
 def parprint(str):
     if DEBUG:
         if parallelComm.procID == 0:
-            print >> sys.stderr, str
+            print(str, file=sys.stderr)
 
 class GmshException(Exception):
     pass
@@ -98,7 +105,7 @@ def gmshVersion(communicator=parallelComm):
         while True:
             try:
                 p = Popen(["gmsh", "--version"], stderr=PIPE)
-            except OSError, e:
+            except OSError as e:
                 verStr = None
                 break
 
@@ -269,7 +276,7 @@ def openPOSFile(name, communicator=parallelComm, mode='w'):
                    communicator=communicator, 
                    mode=mode)
     
-class GmshFile:
+class GmshFile(object):
     def __init__(self, filename, communicator, mode, fileIsTemporary=False):
         self.filename = filename
         self.communicator = communicator
@@ -301,18 +308,18 @@ class GmshFile:
         elif (vertices == 5 and dimensions == 3):
             return 7 ## pyramid
         else:
-            raise MeshExportError, "Element type unsupported by Gmsh"
+            raise MeshExportError("Element type unsupported by Gmsh")
     
     def _orderVertices(self, vertexCoords, vertices):
         coordinates = nx.take(vertexCoords, vertices, axis=1)
-        centroid = nx.add.reduce(coordinates, axis=1) / coordinates.shape[1]
+        centroid = old_div(nx.add.reduce(coordinates, axis=1), coordinates.shape[1])
         coordinates = coordinates - centroid[..., nx.newaxis]
 
         # to prevent div by zero
         coordinates = nx.where(coordinates == 0, 1.e-10, coordinates)
 
         # angles go from -pi / 2 to 3*pi / 2
-        angles = nx.arctan(coordinates[1] / coordinates[0]) \
+        angles = nx.arctan(old_div(coordinates[1], coordinates[0])) \
                 + nx.where(coordinates[0] < 0, nx.pi, 0) 
         sortorder = nx.argsort(angles)
         return nx.take(vertices, sortorder)
@@ -545,7 +552,7 @@ class MSHFile(GmshFile):
         newF = os.fdopen(newF, 'w')
         try:
             self._seekForHeader(title)
-        except Exception, e:
+        except Exception as e:
             newF.close()
             os.unlink(newPath)
             raise
@@ -714,7 +721,7 @@ class MSHFile(GmshFile):
         self.elemsPath = self._isolateData("Elements")
         try:
             self.namesPath = self._isolateData("PhysicalNames")
-        except EOFError, e:
+        except EOFError as e:
             self.namesPath = None
             
         try:
@@ -834,7 +841,7 @@ class MSHFile(GmshFile):
                 
             self.physicalFaceMap = nx.zeros(facesToV.shape[-1:], 'l')
             self.geometricalFaceMap = nx.zeros(facesToV.shape[-1:], 'l')
-            for face in facesDict.keys():
+            for face in list(facesDict.keys()):
                 # not all faces are necessarily tagged
                 if face in faceEntitiesDict:
                     self.physicalFaceMap[facesDict[face]] = faceEntitiesDict[face][0]
@@ -919,7 +926,7 @@ class MSHFile(GmshFile):
                 self.fileobj.write(str(coords[2, i]))
                 self.fileobj.write (" \n")
             else:
-                raise MeshExportError, "Mesh has fewer than 2 or more than 3 dimensions" 
+                raise MeshExportError("Mesh has fewer than 2 or more than 3 dimensions") 
 
         self.fileobj.write("$EndNodes\n")
 
@@ -1074,7 +1081,7 @@ class MSHFile(GmshFile):
             currLineInts = [int(x) for x in el.split()]
             elemType     = currLineInts[1]
 
-            if elemType in self.numFacesPerCell.keys():
+            if elemType in list(self.numFacesPerCell.keys()):
                 # element is a cell
                 
                 (cellOffset, 
@@ -1108,7 +1115,7 @@ class MSHFile(GmshFile):
                     cellsData.add(currLine=currLineInts, elType=elemType, 
                                   physicalEntity=physicalEntity, 
                                   geometricalEntity=geometricalEntity)
-            elif elemType in self.numVertsPerFace.keys():
+            elif elemType in list(self.numVertsPerFace.keys()):
                 # element is a face
                 
                 (faceOffset, 
@@ -1168,11 +1175,11 @@ class MSHFile(GmshFile):
         self.geometricalFaceMap = FaceVariable(mesh=mesh, value=self.geometricalFaceMap)
 
         physicalCells = dict()
-        for name in self.physicalNames[self.dimensions].keys():
+        for name in list(self.physicalNames[self.dimensions].keys()):
             physicalCells[name] = (self.physicalCellMap == self.physicalNames[self.dimensions][name])
             
         physicalFaces = dict()
-        for name in self.physicalNames[self.dimensions-1].keys():
+        for name in list(self.physicalNames[self.dimensions-1].keys()):
             physicalFaces[name] = (self.physicalFaceMap == self.physicalNames[self.dimensions-1][name])
             
         return (self.physicalCellMap,
@@ -2165,10 +2172,10 @@ class GmshGrid2D(Gmsh2D):
     def _makeGridGeo(self, dx, dy, nx, ny):
         height = ny * dy
         width  = nx * dx
-        numLayers = int(ny / float(dy))
+        numLayers = int(old_div(ny, float(dy)))
 
         # kludge: must offset cellSize by `eps` to work properly
-        eps = float(dx)/(nx * 10) 
+        eps = old_div(float(dx),(nx * 10)) 
 
         return """
             ny       = %(ny)g;
@@ -2237,7 +2244,7 @@ class GmshGrid3D(Gmsh3D):
         width  = nx * dx
         depth  = nz * dz
 
-        eps = float(dx)/(nx * 10)
+        eps = old_div(float(dx),(nx * 10))
         
         return """
             ny       = %(ny)g;
diff --git a/fipy/meshes/mesh.py b/fipy/meshes/mesh.py
index 6763066..e62b67c 100644
--- a/fipy/meshes/mesh.py
+++ b/fipy/meshes/mesh.py
@@ -37,6 +37,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.meshes.abstractMesh import AbstractMesh
@@ -185,13 +188,13 @@ class Mesh(AbstractMesh):
         faceOrigins = numerix.repeat(faceVertexCoords[:,0], faceVertexIDs.shape[0], axis=0)
         faceOrigins = numerix.reshape(faceOrigins, MA.shape(faceVertexCoords))
         faceVertexCoords = faceVertexCoords - faceOrigins
-        left = range(faceVertexIDs.shape[0])
+        left = list(range(faceVertexIDs.shape[0]))
         right = left[1:] + [left[0]]
         cross = numerix.sum(numerix.cross(faceVertexCoords, 
                                           numerix.take(faceVertexCoords, right, 1), 
                                           axis=0), 
                             1)
-        return numerix.sqrtDot(cross, cross) / 2.
+        return old_div(numerix.sqrtDot(cross, cross), 2.)
     
     def _calcFaceCenters(self):
         maskedFaceVertexIDs = MA.filled(self.faceVertexIDs, 0)
@@ -218,7 +221,7 @@ class Mesh(AbstractMesh):
         norm = numerix.cross(t1, t2, axis=0)
         ## reordering norm's internal memory for inlining
         norm = norm.copy()
-        norm = norm / numerix.sqrtDot(norm, norm)
+        norm = old_div(norm, numerix.sqrtDot(norm, norm))
         
         faceNormals = -norm
         
@@ -232,7 +235,7 @@ class Mesh(AbstractMesh):
         norm = numerix.cross(t1, t2, axis=0)
         ## reordering norm's internal memory for inlining
         norm = norm.copy()
-        norm = norm / numerix.sqrtDot(norm, norm)
+        norm = old_div(norm, numerix.sqrtDot(norm, norm))
         
         faceNormals = -norm
         
@@ -248,7 +251,7 @@ class Mesh(AbstractMesh):
 
         diff = faceCellCentersDown - faceCellCentersUp
         mag = numerix.sqrt(numerix.sum(diff**2))
-        faceCellToCellNormals = diff / numerix.resize(mag, (self.dim, len(mag)))
+        faceCellToCellNormals = old_div(diff, numerix.resize(mag, (self.dim, len(mag))))
 
         orientation = 1 - 2 * (numerix.dot(self.faceNormals, faceCellToCellNormals) < 0)
         return faceCellToCellNormals * orientation
@@ -287,9 +290,9 @@ class Mesh(AbstractMesh):
                                                      self.faceVertexIDs[0], 
                                                      axis=1))
         tmp = self._faceCenters - faceVertexCoord
-        faceTangents1 = tmp / numerix.sqrtDot(tmp, tmp)
+        faceTangents1 = old_div(tmp, numerix.sqrtDot(tmp, tmp))
         tmp = numerix.cross(faceTangents1, self.faceNormals, axis=0)
-        faceTangents2 = tmp / numerix.sqrtDot(tmp, tmp)
+        faceTangents2 = old_div(tmp, numerix.sqrtDot(tmp, tmp))
         return faceTangents1, faceTangents2
         
     def _calcCellToCellDist(self):
@@ -389,10 +392,10 @@ class Mesh(AbstractMesh):
         dAP = self._cellDistances
         dFP = self._faceToCellDistances[0]
         
-        return MA.filled(dFP / dAP)
+        return MA.filled(old_div(dFP, dAP))
        
     def _calcFaceAspectRatios(self):
-        return self._scaledFaceAreas / self._cellDistances
+        return old_div(self._scaledFaceAreas, self._cellDistances)
     
     def __mul__(self, factor):
         """
diff --git a/fipy/meshes/mesh1D.py b/fipy/meshes/mesh1D.py
index 94a3bc8..deceda5 100644
--- a/fipy/meshes/mesh1D.py
+++ b/fipy/meshes/mesh1D.py
@@ -94,7 +94,7 @@ class Mesh1D(Mesh):
     def _VTKCellType(self):
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
         return tvtk.Line().cell_type
 
diff --git a/fipy/meshes/mesh2D.py b/fipy/meshes/mesh2D.py
index e631d26..2c01df3 100644
--- a/fipy/meshes/mesh2D.py
+++ b/fipy/meshes/mesh2D.py
@@ -43,6 +43,10 @@ Meshes contain cells, faces, and vertices.
 
 This is built for a non-mixed element mesh.
 """
+from __future__ import division
+from builtins import zip
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -55,12 +59,12 @@ from fipy.meshes.topologies.meshTopology import _Mesh2DTopology
 
 def _orderVertices(vertexCoords, vertices):
     coordinates = numerix.take(vertexCoords, vertices)
-    centroid = numerix.add.reduce(coordinates) / coordinates.shape[0]
+    centroid = old_div(numerix.add.reduce(coordinates), coordinates.shape[0])
     coordinates = coordinates - centroid
     # to prevent division by zero
     coordinates = numerix.where(coordinates == 0, 1.e-100, coordinates) 
     # angles go from -pi / 2 to 3*pi / 2
-    angles = numerix.arctan(coordinates[:, 1] / coordinates[:, 0]) \
+    angles = numerix.arctan(old_div(coordinates[:, 1], coordinates[:, 0])) \
                + numerix.where(coordinates[:, 0] < 0, numerix.pi, 0) 
     sortorder = numerix.argsort(angles)
     return numerix.take(vertices, sortorder)
@@ -88,8 +92,8 @@ class Mesh2D(Mesh):
         t1 = faceVertexCoords[:,1,:] - faceVertexCoords[:,0,:]
         faceNormals = t1.copy()
         mag = numerix.sqrt(t1[1]**2 + t1[0]**2)
-        faceNormals[0] = -t1[1] / mag
-        faceNormals[1] = t1[0] / mag
+        faceNormals[0] = old_div(-t1[1], mag)
+        faceNormals[1] = old_div(t1[0], mag)
         
         orientation = 1 - 2 * (numerix.dot(faceNormals, self.cellDistanceVectors) < 0)
         return faceNormals * orientation
@@ -137,7 +141,7 @@ class Mesh2D(Mesh):
         # so the cross product will be zero.
     
         faceDisplacementVectors = \
-          numerix.where(numerix.array(zip(exteriorFaceArray, exteriorFaceArray)),
+          numerix.where(numerix.array(list(zip(exteriorFaceArray, exteriorFaceArray))),
                         0.0, 
                         numerix.take(self._scaledCellCenters.swapaxes(0,1), 
                                      unmaskedFaceCellIDs[1, :]) \
@@ -152,7 +156,7 @@ class Mesh2D(Mesh):
         faceDisplacementVectorLengths = numerix.maximum(((faceDisplacementVectors[0, :] ** 2) \
           + (faceDisplacementVectors[1, :] ** 2)) ** 0.5, 1.e-100)
 
-        faceWeightedNonOrthogonalities = abs(faceCrossProducts / faceDisplacementVectorLengths) * self._faceAreas
+        faceWeightedNonOrthogonalities = abs(old_div(faceCrossProducts, faceDisplacementVectorLengths)) * self._faceAreas
 
         cellFaceWeightedNonOrthogonalities = numerix.take(faceWeightedNonOrthogonalities, self.cellFaceIDs)
 
@@ -160,7 +164,7 @@ class Mesh2D(Mesh):
         cellTotalWeightedValues = numerix.add.reduce(cellFaceWeightedNonOrthogonalities, axis = 0)  
         cellTotalFaceAreas = numerix.add.reduce(cellFaceAreas, axis = 0)
   
-        return (cellTotalWeightedValues / cellTotalFaceAreas)
+        return (old_div(cellTotalWeightedValues, cellTotalFaceAreas))
 
     def extrude(self, extrudeFunc=lambda x: x + numerix.array((0, 0, 1))[:,numerix.newaxis] , layers=1):
         """
@@ -262,7 +266,7 @@ class Mesh2D(Mesh):
     def _VTKCellType(self):
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
         return tvtk.Polygon().cell_type
     
diff --git a/fipy/meshes/representations/abstractRepresentation.py b/fipy/meshes/representations/abstractRepresentation.py
index 3ed6643..ad7b657 100644
--- a/fipy/meshes/representations/abstractRepresentation.py
+++ b/fipy/meshes/representations/abstractRepresentation.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/meshes/representations/gridRepresentation.py b/fipy/meshes/representations/gridRepresentation.py
index 8e55ccb..6ab341e 100644
--- a/fipy/meshes/representations/gridRepresentation.py
+++ b/fipy/meshes/representations/gridRepresentation.py
@@ -1,3 +1,4 @@
+from builtins import str
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/meshes/skewedGrid2D.py b/fipy/meshes/skewedGrid2D.py
index 5b45d54..4141001 100644
--- a/fipy/meshes/skewedGrid2D.py
+++ b/fipy/meshes/skewedGrid2D.py
@@ -32,6 +32,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
  
 from fipy.tools import numerix
@@ -80,7 +83,7 @@ class SkewedGrid2D(Mesh2D):
         changedVertices = numerix.zeros(vertices.shape, 'd')
 
         for i in range(len(vertices[0])):
-            if((i % (nx+1)) != 0 and (i % (nx+1)) != nx and (i / nx+1) != 0 and (i / nx+1) != ny):
+            if((i % (nx+1)) != 0 and (i % (nx+1)) != nx and (old_div(i, nx)+1) != 0 and (old_div(i, nx)+1) != ny):
                 changedVertices[0, i] = vertices[0, i] + (rand * ((random.random() * 2) - 1))
                 changedVertices[1, i] = vertices[1, i] + (rand * ((random.random() * 2) - 1))
             else:
diff --git a/fipy/meshes/topologies/abstractTopology.py b/fipy/meshes/topologies/abstractTopology.py
index fd8e24a..8710e9c 100644
--- a/fipy/meshes/topologies/abstractTopology.py
+++ b/fipy/meshes/topologies/abstractTopology.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/meshes/uniformGrid1D.py b/fipy/meshes/uniformGrid1D.py
index 15c39d6..726db92 100644
--- a/fipy/meshes/uniformGrid1D.py
+++ b/fipy/meshes/uniformGrid1D.py
@@ -36,6 +36,8 @@
 """
 1D Mesh
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -202,8 +204,8 @@ class UniformGrid1D(UniformGrid):
         distances = numerix.ones(self.numberOfFaces, 'd')
         distances *= self.dx
         if len(distances) > 0:
-            distances[0] = self.dx / 2.
-            distances[-1] = self.dx / 2.
+            distances[0] = old_div(self.dx, 2.)
+            distances[-1] = old_div(self.dx, 2.)
         return distances
 
     @property
@@ -219,8 +221,8 @@ class UniformGrid1D(UniformGrid):
         distances = MA.zeros((2, self.numberOfCells), 'd')
         distances[:] = self.dx
         if self.numberOfCells > 0:
-            distances[0,0] = self.dx / 2.
-            distances[1,-1] = self.dx / 2.
+            distances[0,0] = old_div(self.dx, 2.)
+            distances[1,-1] = old_div(self.dx, 2.)
         return distances
 
     @property
@@ -265,7 +267,7 @@ class UniformGrid1D(UniformGrid):
         
     @property
     def _getFaceAspectRatios(self):
-        return 1. / self._cellDistances
+        return old_div(1., self._cellDistances)
 
 
     def _translate(self, vector):
@@ -339,7 +341,7 @@ class UniformGrid1D(UniformGrid):
         xi, = points
         dx = self.dx
         
-        i = numerix.array(numerix.rint(((xi - x0) / dx)), 'l')
+        i = numerix.array(numerix.rint((old_div((xi - x0), dx))), 'l')
         i[i < 0] = 0
         i[i > nx - 1] = nx - 1
 
diff --git a/fipy/meshes/uniformGrid2D.py b/fipy/meshes/uniformGrid2D.py
index 490b845..2016fd6 100644
--- a/fipy/meshes/uniformGrid2D.py
+++ b/fipy/meshes/uniformGrid2D.py
@@ -36,6 +36,8 @@
 """
 2D rectangular Mesh with constant spacing in x and constant spacing in y
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -289,7 +291,7 @@ class UniformGrid2D(UniformGrid):
                  
     @property
     def _faceAspectRatios(self):
-        return self._faceAreas / self._cellDistances  
+        return old_div(self._faceAreas, self._cellDistances)  
    
     @property
     def _faceAreas(self):
@@ -330,14 +332,14 @@ class UniformGrid2D(UniformGrid):
         Hdis = numerix.repeat((self.dy,), self.numberOfHorizontalFaces)
         Hdis = numerix.reshape(Hdis, (self.nx, self.numberOfHorizontalRows))
         if self.numberOfHorizontalRows > 0:
-            Hdis[...,0] = self.dy / 2.
-            Hdis[...,-1] = self.dy / 2.
+            Hdis[...,0] = old_div(self.dy, 2.)
+            Hdis[...,-1] = old_div(self.dy, 2.)
         
         Vdis = numerix.repeat((self.dx,), self.numberOfFaces - self.numberOfHorizontalFaces)
         Vdis = numerix.reshape(Vdis, (self.numberOfVerticalColumns, self.ny))
         if self.numberOfVerticalColumns > 0:
-            Vdis[0,...] = self.dx / 2.
-            Vdis[-1,...] = self.dx / 2.
+            Vdis[0,...] = old_div(self.dx, 2.)
+            Vdis[-1,...] = old_div(self.dx, 2.)
 
         return numerix.concatenate((numerix.reshape(numerix.swapaxes(Hdis,0,1), (self.numberOfHorizontalFaces,)), 
                                     numerix.reshape(numerix.swapaxes(Vdis,0,1), (self.numberOfFaces - self.numberOfHorizontalFaces,))))
@@ -397,11 +399,11 @@ class UniformGrid2D(UniformGrid):
         distances[3] = self.dx
         
         if self.ny > 0:
-            distances[0,..., 0] = self.dy / 2.
-            distances[2,...,-1] = self.dy / 2.
+            distances[0,..., 0] = old_div(self.dy, 2.)
+            distances[2,...,-1] = old_div(self.dy, 2.)
         if self.nx > 0:
-            distances[3, 0,...] = self.dx / 2.
-            distances[1,-1,...] = self.dx / 2.
+            distances[3, 0,...] = old_div(self.dx, 2.)
+            distances[1,-1,...] = old_div(self.dx, 2.)
         
         return distances.reshape((4, self.numberOfCells), order="FORTRAN")
 
@@ -614,11 +616,11 @@ class UniformGrid2D(UniformGrid):
         xi, yi = points
         dx, dy = self.dx, self.dy
         
-        i = numerix.array(numerix.rint(((xi - x0) / dx)), 'l')
+        i = numerix.array(numerix.rint((old_div((xi - x0), dx))), 'l')
         i[i < 0] = 0
         i[i > nx - 1] = nx - 1
 
-        j = numerix.array(numerix.rint(((yi - y0) / dy)), 'l')
+        j = numerix.array(numerix.rint((old_div((yi - y0), dy))), 'l')
         j[j < 0] = 0
         j[j > ny - 1]  = ny - 1
 
diff --git a/fipy/meshes/uniformGrid3D.py b/fipy/meshes/uniformGrid3D.py
index a418f65..0235da2 100644
--- a/fipy/meshes/uniformGrid3D.py
+++ b/fipy/meshes/uniformGrid3D.py
@@ -33,6 +33,8 @@
  # ########################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 from fipy.tools import numerix
 from fipy.tools.numerix import MA
 from fipy.tools import parallelComm
@@ -239,18 +241,18 @@ class UniformGrid3D(UniformGrid):
     def _cellDistances(self):
         XYdis = numerix.zeros((self.nz + 1, self.ny, self.nx),'d')
         XYdis[:] = self.dz
-        XYdis[ 0,...] = self.dz / 2.
-        XYdis[-1,...] = self.dz / 2.
+        XYdis[ 0,...] = old_div(self.dz, 2.)
+        XYdis[-1,...] = old_div(self.dz, 2.)
 
         XZdis = numerix.zeros((self.nz, self.ny + 1, self.nx),'d')
         XZdis[:] = self.dy
-        XZdis[..., 0,...] = self.dy / 2.
-        XZdis[...,-1,...] = self.dy / 2.
+        XZdis[..., 0,...] = old_div(self.dy, 2.)
+        XZdis[...,-1,...] = old_div(self.dy, 2.)
 
         YZdis = numerix.zeros((self.nz, self.ny, self.nx + 1),'d')
         YZdis[:] = self.dx
-        YZdis[..., 0] = self.dx / 2.
-        YZdis[...,-1] = self.dx / 2.
+        YZdis[..., 0] = old_div(self.dx, 2.)
+        YZdis[...,-1] = old_div(self.dx, 2.)
 
         return numerix.concatenate((numerix.ravel(XYdis),
                                     numerix.ravel(XZdis),
@@ -321,12 +323,12 @@ class UniformGrid3D(UniformGrid):
         distances[4] = self.dz
         distances[5] = self.dz
 
-        distances[0,  0,...    ] = self.dx / 2.
-        distances[1, -1,...    ] = self.dx / 2.
-        distances[2,...,  0,...] = self.dy / 2.
-        distances[3,..., -1,...] = self.dy / 2.
-        distances[4,...,      0] = self.dz / 2.
-        distances[5,...,     -1] = self.dz / 2.
+        distances[0,  0,...    ] = old_div(self.dx, 2.)
+        distances[1, -1,...    ] = old_div(self.dx, 2.)
+        distances[2,...,  0,...] = old_div(self.dy, 2.)
+        distances[3,..., -1,...] = old_div(self.dy, 2.)
+        distances[4,...,      0] = old_div(self.dz, 2.)
+        distances[5,...,     -1] = old_div(self.dz, 2.)
 
         return numerix.reshape(distances.swapaxes(1,3), (self.numberOfCells, 6))
 
@@ -394,7 +396,7 @@ class UniformGrid3D(UniformGrid):
 
     @property
     def _faceAspectRatios(self):
-        return self._faceAreas / self._cellDistances
+        return old_div(self._faceAreas, self._cellDistances)
 
     def _translate(self, vector):
         return self.__class__(dx = self.args['dx'], nx = self.args['nx'],
@@ -524,15 +526,15 @@ class UniformGrid3D(UniformGrid):
         nx, ny, nz = self.shape
         dx, dy, dz = self.dx, self.dy, self.dz
 
-        i = numerix.array(numerix.rint(((xi - x0) / dx)), 'l')
+        i = numerix.array(numerix.rint((old_div((xi - x0), dx))), 'l')
         i[i < 0] = 0
         i[i > nx - 1] = nx - 1
 
-        j = numerix.array(numerix.rint(((yi - y0) / dy)), 'l')
+        j = numerix.array(numerix.rint((old_div((yi - y0), dy))), 'l')
         j[j < 0] = 0
         j[j > ny - 1]  = ny - 1
 
-        k = numerix.array(numerix.rint(((zi - z0) / dz)), 'l')
+        k = numerix.array(numerix.rint((old_div((zi - z0), dz))), 'l')
         k[k < 0] = 0
         k[k > nz - 1]  = nz - 1
 
diff --git a/fipy/solvers/__init__.py b/fipy/solvers/__init__.py
index 9803def..ff0a899 100644
--- a/fipy/solvers/__init__.py
+++ b/fipy/solvers/__init__.py
@@ -119,7 +119,7 @@ elif solver is None:
                         
 
 else:
-    raise ImportError, 'Unknown solver package %s' % solver
+    raise ImportError('Unknown solver package %s' % solver)
 
 
 from fipy.tests.doctestPlus import register_skipper
diff --git a/fipy/solvers/pyAMG/preconditioners/smoothedAggregationPreconditioner.py b/fipy/solvers/pyAMG/preconditioners/smoothedAggregationPreconditioner.py
index 817cda2..9201236 100644
--- a/fipy/solvers/pyAMG/preconditioners/smoothedAggregationPreconditioner.py
+++ b/fipy/solvers/pyAMG/preconditioners/smoothedAggregationPreconditioner.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -37,7 +38,7 @@ from pyamg import smoothed_aggregation_solver
 
 __all__ = ["SmoothedAggregationPreconditioner"]
 
-class SmoothedAggregationPreconditioner():
+class SmoothedAggregationPreconditioner(object):
     def __init__(self):
         pass
         
diff --git a/fipy/solvers/pysparse/linearJORSolver.py b/fipy/solvers/pysparse/linearJORSolver.py
index cf6d809..8bc5c09 100644
--- a/fipy/solvers/pysparse/linearJORSolver.py
+++ b/fipy/solvers/pysparse/linearJORSolver.py
@@ -32,6 +32,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.solvers.pysparse.pysparseSolver import PysparseSolver
@@ -78,11 +82,11 @@ class LinearJORSolver(PysparseSolver):
             residual = L * x - b
 
             xold[:] = x
-            x[:] = (-(LU) * x + b) / d
+            x[:] = old_div((-(LU) * x + b), d)
 
             x[:] = xold + self.relaxation * (x - xold)  
 
             tol = max(abs(residual))
 
-            print iteration,tol
+            print(iteration,tol)
 
diff --git a/fipy/solvers/pysparse/linearLUSolver.py b/fipy/solvers/pysparse/linearLUSolver.py
index 16027af..1be5bc4 100644
--- a/fipy/solvers/pysparse/linearLUSolver.py
+++ b/fipy/solvers/pysparse/linearLUSolver.py
@@ -32,6 +32,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -81,21 +85,21 @@ class LinearLUSolver(PysparseSolver):
         diag = L.takeDiagonal()
         maxdiag = max(numerix.absolute(diag))
 
-        L = L * (1 / maxdiag)
-        b = b * (1 / maxdiag)
+        L = L * (old_div(1, maxdiag))
+        b = b * (old_div(1, maxdiag))
 
         LU = superlu.factorize(L.matrix.to_csr())
 
         if DEBUG:
             import sys
-            print >> sys.stderr, L.matrix
+            print(L.matrix, file=sys.stderr)
 
         error0 = numerix.sqrt(numerix.sum((L * x - b)**2))
 
         for iteration in range(self.iterations):
             errorVector = L * x - b
 
-            if (numerix.sqrt(numerix.sum(errorVector**2)) / error0)  <= self.tolerance:
+            if (old_div(numerix.sqrt(numerix.sum(errorVector**2)), error0))  <= self.tolerance:
                 break
 
             xError = numerix.zeros(len(b),'d')
diff --git a/fipy/solvers/pysparse/preconditioners/preconditioner.py b/fipy/solvers/pysparse/preconditioners/preconditioner.py
index ce73dbc..d7503c9 100644
--- a/fipy/solvers/pysparse/preconditioners/preconditioner.py
+++ b/fipy/solvers/pysparse/preconditioners/preconditioner.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -35,7 +36,7 @@
  
 __all__ = ["Preconditioner"]
 
-class Preconditioner:
+class Preconditioner(object):
     """
     Base preconditioner class
 
@@ -47,8 +48,7 @@ class Preconditioner:
         Create a `Preconditioner` object.
         """
         if self.__class__ is Preconditioner:
-            raise NotImplementedError, \
-                  "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
 
     def _applyToMatrix(self, matrix):
         """
diff --git a/fipy/solvers/pysparse/pysparseSolver.py b/fipy/solvers/pysparse/pysparseSolver.py
index 08c534f..b2d8039 100644
--- a/fipy/solvers/pysparse/pysparseSolver.py
+++ b/fipy/solvers/pysparse/pysparseSolver.py
@@ -48,8 +48,7 @@ class PysparseSolver(_PysparseMatrixSolver):
     """
     def __init__(self, *args, **kwargs):
         if self.__class__ is PysparseSolver:
-            raise NotImplementedError, \
-                  "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         super(PysparseSolver, self).__init__(*args, **kwargs)
 
diff --git a/fipy/solvers/scipy/linearLUSolver.py b/fipy/solvers/scipy/linearLUSolver.py
index e9b07ca..86cc006 100644
--- a/fipy/solvers/scipy/linearLUSolver.py
+++ b/fipy/solvers/scipy/linearLUSolver.py
@@ -32,6 +32,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -54,8 +57,8 @@ class LinearLUSolver(_ScipySolver):
         diag = L.takeDiagonal()
         maxdiag = max(numerix.absolute(diag))
 
-        L = L * (1 / maxdiag)
-        b = b * (1 / maxdiag)
+        L = L * (old_div(1, maxdiag))
+        b = b * (old_div(1, maxdiag))
 
         LU = splu(L.matrix.asformat("csc"), diag_pivot_thresh=1.,
                                             drop_tol=0.,
@@ -68,7 +71,7 @@ class LinearLUSolver(_ScipySolver):
         for iteration in range(min(self.iterations, 10)):
             errorVector = L * x - b
 
-            if (numerix.sqrt(numerix.sum(errorVector**2)) / error0)  <= self.tolerance:
+            if (old_div(numerix.sqrt(numerix.sum(errorVector**2)), error0))  <= self.tolerance:
                 break
 
             xError = LU.solve(errorVector)
diff --git a/fipy/solvers/solver.py b/fipy/solvers/solver.py
index c384ec5..dd8dc9b 100644
--- a/fipy/solvers/solver.py
+++ b/fipy/solvers/solver.py
@@ -46,6 +46,10 @@ can abort whenever it has problems with::
     $ python -Werror::fipy.PreconditionerWarning myscript.py
     
 """
+from __future__ import division
+from builtins import str
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -109,7 +113,7 @@ class Solver(object):
 
         """
         if self.__class__ is Solver:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         self.tolerance = tolerance
         self.iterations = iterations
@@ -129,7 +133,7 @@ class Solver(object):
         
     def _applyUnderRelaxation(self, underRelaxation=None):
         if underRelaxation is not None:
-            self.matrix.putDiagonal(self.matrix.takeDiagonal() / underRelaxation)
+            self.matrix.putDiagonal(old_div(self.matrix.takeDiagonal(), underRelaxation))
             self.RHSvector += (1 - underRelaxation) * self.matrix.takeDiagonal() * numerix.array(self.var).flatten()
 
     def _calcResidualVector(self, residualFn=None):
diff --git a/fipy/solvers/trilinos/linearLUSolver.py b/fipy/solvers/trilinos/linearLUSolver.py
index 3911fa6..c3e8721 100644
--- a/fipy/solvers/trilinos/linearLUSolver.py
+++ b/fipy/solvers/trilinos/linearLUSolver.py
@@ -33,6 +33,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -88,7 +91,7 @@ class LinearLUSolver(TrilinosSolver):
              if iteration == 0:
                  tol0 = tol
                  
-             if (tol / tol0) <= self.tolerance: 
+             if (old_div(tol, tol0)) <= self.tolerance: 
                  break
 
              xError = Epetra.Vector(L.RowMap())
diff --git a/fipy/solvers/trilinos/preconditioners/multilevelDDMLPreconditioner.py b/fipy/solvers/trilinos/preconditioners/multilevelDDMLPreconditioner.py
index 0018f6f..b1c29ce 100644
--- a/fipy/solvers/trilinos/preconditioners/multilevelDDMLPreconditioner.py
+++ b/fipy/solvers/trilinos/preconditioners/multilevelDDMLPreconditioner.py
@@ -42,6 +42,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from PyTrilinos import ML
@@ -68,7 +70,7 @@ class MultilevelDDMLPreconditioner(Preconditioner):
                                     "aggregation: type" : "METIS",
                                     "aggregation: nodes per aggregate" : 512,
                                     "aggregation: next-level aggregates per process" : 128,
-                                    "aggregation: damping factor" : 4. / 3.,
+                                    "aggregation: damping factor" : old_div(4., 3.),
                                     "eigen-analysis: type" : "power-method",
                                     "eigen-analysis: iterations" : 20,
                                     "smoother: sweeps" : 1,
diff --git a/fipy/solvers/trilinos/preconditioners/multilevelDDPreconditioner.py b/fipy/solvers/trilinos/preconditioners/multilevelDDPreconditioner.py
index 1a6739f..60a5f88 100644
--- a/fipy/solvers/trilinos/preconditioners/multilevelDDPreconditioner.py
+++ b/fipy/solvers/trilinos/preconditioners/multilevelDDPreconditioner.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from PyTrilinos import ML
@@ -60,7 +62,7 @@ class MultilevelDDPreconditioner(Preconditioner):
                                     "increasing or decreasing" : "increasing",
                                     "aggregation: type" : "METIS",
                                     "aggregation: local aggregates" : 1,
-                                    "aggregation: damping factor" : 4. / 3.,
+                                    "aggregation: damping factor" : old_div(4., 3.),
                                     "eigen-analysis: type" : "power-method",
                                     "eigen-analysis: iterations" : 20,
                                     "smoother: sweeps" : 1,
diff --git a/fipy/solvers/trilinos/preconditioners/multilevelSAPreconditioner.py b/fipy/solvers/trilinos/preconditioners/multilevelSAPreconditioner.py
index 5aebe7f..27689e3 100644
--- a/fipy/solvers/trilinos/preconditioners/multilevelSAPreconditioner.py
+++ b/fipy/solvers/trilinos/preconditioners/multilevelSAPreconditioner.py
@@ -42,6 +42,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from PyTrilinos import ML
@@ -68,7 +70,7 @@ class MultilevelSAPreconditioner(Preconditioner):
                                     "prec type" : "MGV",
                                     "increasing or decreasing" : "increasing",
                                     "aggregation: type" : "Uncoupled-MIS",
-                                    "aggregation: damping factor" : 4. / 3.,
+                                    "aggregation: damping factor" : old_div(4., 3.),
 ##                                    "energy minimization: enable" : False,
 ##                                    "smoother: type" : "Aztec",
 ##                                    "smoother: type" : "symmetric Gauss-Seidel",
diff --git a/fipy/solvers/trilinos/preconditioners/preconditioner.py b/fipy/solvers/trilinos/preconditioners/preconditioner.py
index 5e6b4ba..6566a30 100644
--- a/fipy/solvers/trilinos/preconditioners/preconditioner.py
+++ b/fipy/solvers/trilinos/preconditioners/preconditioner.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## 
@@ -38,7 +39,7 @@ __docformat__ = 'restructuredtext'
 
 __all__ = ["Preconditioner"]
 
-class Preconditioner:
+class Preconditioner(object):
     """
     The base Preconditioner class.
     
@@ -50,7 +51,7 @@ class Preconditioner:
         Create a `Preconditioner` object.
         """
         if self.__class__ is Preconditioner:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
 	
     def _applyToSolver(self, solver, matrix):
         raise NotImplementedError
diff --git a/fipy/solvers/trilinos/trilinosAztecOOSolver.py b/fipy/solvers/trilinos/trilinosAztecOOSolver.py
index 2fa9969..9adaa3a 100644
--- a/fipy/solvers/trilinos/trilinosAztecOOSolver.py
+++ b/fipy/solvers/trilinos/trilinosAztecOOSolver.py
@@ -60,7 +60,7 @@ class TrilinosAztecOOSolver(TrilinosSolver):
 
         """
         if self.__class__ is TrilinosAztecOOSolver:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         TrilinosSolver.__init__(self, tolerance=tolerance,
                                 iterations=iterations, precon=None)
diff --git a/fipy/solvers/trilinos/trilinosMLTest.py b/fipy/solvers/trilinos/trilinosMLTest.py
index f954824..b8e4cc5 100644
--- a/fipy/solvers/trilinos/trilinosMLTest.py
+++ b/fipy/solvers/trilinos/trilinosMLTest.py
@@ -1,3 +1,4 @@
+from builtins import input
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -99,6 +100,6 @@ class TrilinosMLTest(TrilinosSolver):
         Prec.ComputePreconditioner()
 
         Prec.TestSmoothers()
-        raw_input("Results of preconditioner tests shown above. Currently, the first tests in the 'Gauss-Seidel (sym)','Aztec preconditioner', and 'Aztec as solver' sections indicate the expected performance of the MultilevelSGSPreconditioner, MultilevelDDPreconditioner, and MultilevelSolverSmootherPreconditioner classes, respectively.\n\nPress enter to quit.")
+        input("Results of preconditioner tests shown above. Currently, the first tests in the 'Gauss-Seidel (sym)','Aztec preconditioner', and 'Aztec as solver' sections indicate the expected performance of the MultilevelSGSPreconditioner, MultilevelDDPreconditioner, and MultilevelSolverSmootherPreconditioner classes, respectively.\n\nPress enter to quit.")
         import sys
         sys.exit(0)
diff --git a/fipy/solvers/trilinos/trilinosNonlinearSolver.py b/fipy/solvers/trilinos/trilinosNonlinearSolver.py
index 86cde0b..cc7015e 100644
--- a/fipy/solvers/trilinos/trilinosNonlinearSolver.py
+++ b/fipy/solvers/trilinos/trilinosNonlinearSolver.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import str
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -101,9 +103,9 @@ class _NOXInterface(NOX.Epetra.Interface.Required, NOX.Epetra.Interface.Jacobian
             
             return True
             
-        except Exception, e:
-            print "TrilinosNonlinearSolver.computeJacobian() has thrown an exception:"
-            print str(type(e))[18:-2] + ":", e
+        except Exception as e:
+            print("TrilinosNonlinearSolver.computeJacobian() has thrown an exception:")
+            print(str(type(e))[18:-2] + ":", e)
             return False
 
         
@@ -121,9 +123,9 @@ class _NOXInterface(NOX.Epetra.Interface.Required, NOX.Epetra.Interface.Jacobian
             
             return True
             
-        except Exception, e:
-            print "TrilinosNonlinearSolver.computeF() has thrown an exception:"
-            print str(type(e))[18:-2] + ":", e
+        except Exception as e:
+            print("TrilinosNonlinearSolver.computeF() has thrown an exception:")
+            print(str(type(e))[18:-2] + ":", e)
             return False
             
 class _DummyJacobianSolver(TrilinosSolver):
diff --git a/fipy/solvers/trilinos/trilinosSolver.py b/fipy/solvers/trilinos/trilinosSolver.py
index 0a0b320..4784c54 100644
--- a/fipy/solvers/trilinos/trilinosSolver.py
+++ b/fipy/solvers/trilinos/trilinosSolver.py
@@ -49,7 +49,7 @@ class TrilinosSolver(Solver):
     """
     def __init__(self, *args, **kwargs):
         if self.__class__ is TrilinosSolver:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
         else:
             Solver.__init__(self, *args, **kwargs)
 
diff --git a/fipy/steppers/__init__.py b/fipy/steppers/__init__.py
index 7899129..355ddfb 100644
--- a/fipy/steppers/__init__.py
+++ b/fipy/steppers/__init__.py
@@ -1,3 +1,5 @@
+from __future__ import division
+from past.utils import old_div
 ## -*-Pyth-*-
  # ########################################################################
  # FiPy - a finite volume PDE solver in Python
@@ -77,7 +79,7 @@ def error(var, matrix, RHSvector, norm):
     """
     from fipy.tools.numerix import L1norm
     denom = L1norm(var.old)
-    return L1norm(var - var.old) / (denom + (denom == 0))
+    return old_div(L1norm(var - var.old), (denom + (denom == 0)))
 
 def L1error(var, matrix, RHSvector):
     r"""
diff --git a/fipy/steppers/pidStepper.py b/fipy/steppers/pidStepper.py
index b699693..91d66ac 100644
--- a/fipy/steppers/pidStepper.py
+++ b/fipy/steppers/pidStepper.py
@@ -1,3 +1,5 @@
+from __future__ import division
+from past.utils import old_div
 ## -*-Pyth-*-
  # ########################################################################
  # FiPy - a finite volume PDE solver in Python
@@ -74,18 +76,18 @@ class PIDStepper(Stepper):
                 for var, eqn, bcs in self.vardata:
                     var.setValue(var.old)
 
-                factor = min(1. / self.error[2], 0.8)
+                factor = min(old_div(1., self.error[2]), 0.8)
                 
                 dt = self._lowerBound(factor * dt)
                 
-                dtPrev = dt**2 / dtPrev
+                dtPrev = old_div(dt**2, dtPrev)
             else:
                 # step succeeded
                 break
                 
-        dtNext = dtPrev * ((self.error[1] / self.error[2])**self.proportional 
-                           * (1. / self.error[2])**self.integral 
-                           * (self.error[1]**2 / (self.error[2] * self.error[0]))**self.derivative) 
+        dtNext = dtPrev * ((old_div(self.error[1], self.error[2]))**self.proportional 
+                           * (old_div(1., self.error[2]))**self.integral 
+                           * (old_div(self.error[1]**2, (self.error[2] * self.error[0])))**self.derivative) 
               
         self.error[0] = self.error[1]
         self.error[1] = self.error[2]
diff --git a/fipy/steppers/stepper.py b/fipy/steppers/stepper.py
index 66f9f8b..efc056b 100644
--- a/fipy/steppers/stepper.py
+++ b/fipy/steppers/stepper.py
@@ -1,3 +1,4 @@
+from builtins import object
 ## -*-Pyth-*-
  # ########################################################################
  # FiPy - a finite volume PDE solver in Python
@@ -34,7 +35,7 @@ __docformat__ = 'restructuredtext'
 
 __all__ = ["Stepper"]
 
-class Stepper:
+class Stepper(object):
     def __init__(self, vardata=()):
         self.vardata = vardata
         
diff --git a/fipy/terms/abstractConvectionTerm.py b/fipy/terms/abstractConvectionTerm.py
index cdd298d..1a39a2a 100644
--- a/fipy/terms/abstractConvectionTerm.py
+++ b/fipy/terms/abstractConvectionTerm.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -168,7 +170,7 @@ class _AbstractConvectionTerm(FaceTerm):
             else:
                 diffCoeff = diffusionGeomCoeff[0].numericValue
                 diffCoeff = diffCoeff - (diffCoeff == 0) * geomCoeff / pecletLarge
-                peclet = -geomCoeff / diffCoeff
+                peclet = old_div(-geomCoeff, diffCoeff)
                     
             alpha = self._alpha(peclet)
 
diff --git a/fipy/terms/abstractDiffusionTerm.py b/fipy/terms/abstractDiffusionTerm.py
index 832bcdc..de525ea 100644
--- a/fipy/terms/abstractDiffusionTerm.py
+++ b/fipy/terms/abstractDiffusionTerm.py
@@ -32,6 +32,9 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import input
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -125,7 +128,7 @@ class _AbstractDiffusionTerm(_UnaryTerm):
 
                 rotationTensor[0, 1] = 1
                 rotationTensor[:, 1] = numerix.where(flag,
-                                                     rotationTensor[:,0].dot((((0, 1, 0), (-1, 0, 0), (0, 0, 0)))) / div,
+                                                     old_div(rotationTensor[:,0].dot((((0, 1, 0), (-1, 0, 0), (0, 0, 0)))), div),
                                                      rotationTensor[:, 1])
 
 
@@ -167,7 +170,7 @@ class _AbstractDiffusionTerm(_UnaryTerm):
             elif var.rank == 1:
                 anisotropicRank = rank - 2
             else:
-                raise IndexError, 'the solution variable has the wrong rank'
+                raise IndexError('the solution variable has the wrong rank')
                 
             if anisotropicRank == 0 and self._treatMeshAsOrthogonal(mesh):
                 
@@ -184,11 +187,11 @@ class _AbstractDiffusionTerm(_UnaryTerm):
                 if anisotropicRank > 0:
                     shape = numerix.getShape(coeff)
                     if mesh.dim != shape[0] or mesh.dim != shape[1]:
-                        raise IndexError, 'diffusion coefficent tensor is not an appropriate shape for this mesh'          
+                        raise IndexError('diffusion coefficent tensor is not an appropriate shape for this mesh')          
                     
                 faceNormals = FaceVariable(mesh=mesh, rank=1, value=mesh.faceNormals)
                 rotationTensor = self.__getRotationTensor(mesh)
-                rotationTensor[:,0] = rotationTensor[:,0] / mesh._cellDistances
+                rotationTensor[:,0] = old_div(rotationTensor[:,0], mesh._cellDistances)
 
                 tmpBop = faceNormals.dot(coeff).dot(rotationTensor) * mesh._faceAreas
 
@@ -273,7 +276,7 @@ class _AbstractDiffusionTerm(_UnaryTerm):
                 self._viewer.title = r"%s %s" % (boundaryCondition.__class__.__name__, self.__class__.__name__)
                 self._viewer.plot(matrix=LL, RHSvector=bb)
                 from fipy import raw_input
-                raw_input()
+                input()
             self.__bcAdd(coefficientMatrix, boundaryB, LL, bb) 
             
         return coefficientMatrix, boundaryB
@@ -371,10 +374,10 @@ class _AbstractDiffusionTerm(_UnaryTerm):
                                                                                       diffusionGeomCoeff=diffusionGeomCoeff)
             del lowerOrderBCs
             
-            lowerOrderb = lowerOrderb / mesh.cellVolumes
+            lowerOrderb = old_div(lowerOrderb, mesh.cellVolumes)
             volMatrix = SparseMatrix(mesh=var.mesh, bandwidth = 1)
             
-            volMatrix.addAtDiagonal(1. / mesh.cellVolumes)
+            volMatrix.addAtDiagonal(old_div(1., mesh.cellVolumes))
             lowerOrderL = volMatrix * lowerOrderL
             del volMatrix
 
diff --git a/fipy/terms/advectionTerm.py b/fipy/terms/advectionTerm.py
index f919c78..090b10c 100644
--- a/fipy/terms/advectionTerm.py
+++ b/fipy/terms/advectionTerm.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
  
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = ["AdvectionTerm"]
@@ -219,9 +221,9 @@ class AdvectionTerm(FirstOrderAdvectionTerm):
         cellNormalGradient = numerix.dot(cellGradient, mesh._cellNormals)
         cellUpValues = adjacentValues - 2 * dAP * cellNormalGradient
         
-        cellLaplacian = (cellUpValues + adjacentValues - 2 * cellValues) / dAP**2
+        cellLaplacian = old_div((cellUpValues + adjacentValues - 2 * cellValues), dAP**2)
 
-        adjacentLaplacian = (adjacentUpValues + cellValues - 2 * adjacentValues) / dAP**2
+        adjacentLaplacian = old_div((adjacentUpValues + cellValues - 2 * adjacentValues), dAP**2)
         adjacentLaplacian = adjacentLaplacian.filled(0)
         cellLaplacian = cellLaplacian.filled(0)
 
diff --git a/fipy/terms/cellTerm.py b/fipy/terms/cellTerm.py
index 142dadf..e71d228 100644
--- a/fipy/terms/cellTerm.py
+++ b/fipy/terms/cellTerm.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.terms.nonDiffusionTerm import _NonDiffusionTerm
@@ -58,7 +60,7 @@ class CellTerm(_NonDiffusionTerm):
             coeff = _Constant(value=coeff)
 
         if isinstance(coeff, FaceVariable):
-             raise TypeError, "The coefficient can not be a FaceVariable."
+             raise TypeError("The coefficient can not be a FaceVariable.")
 
         _NonDiffusionTerm.__init__(self, coeff=coeff, var=var)
         self.coeffVectors = None
@@ -82,18 +84,18 @@ class CellTerm(_NonDiffusionTerm):
 
         if var.rank == 0:
             if shape != ():
-                raise TypeError, "The coefficient must be rank 0 for a rank 0 solution variable."
+                raise TypeError("The coefficient must be rank 0 for a rank 0 solution variable.")
 
         if shape != () and len(shape) != 2 and shape[0] != shape[1]:
-            raise TypeError, "The coefficient must be a rank-0 or rank-2 vector or a scalar value."
+            raise TypeError("The coefficient must be a rank-0 or rank-2 vector or a scalar value.")
 
         if var.rank == 1:
             if shape == ():
                 pass
             elif len(shape) != 2:
-                raise TypeError, "The coefficient must be rank 2 or rank 0 for a rank 1 solution variable."
+                raise TypeError("The coefficient must be rank 2 or rank 0 for a rank 1 solution variable.")
             elif var.shape[0] != shape[0]:
-                raise TypeError, "The coefficient (N , N) shape must match the the solution variable (N,) shape."
+                raise TypeError("The coefficient (N , N) shape must match the the solution variable (N,) shape.")
         
     def _calcCoeffVectors_(self, var, transientGeomCoeff=None, diffusionGeomCoeff=None):
         coeff = self._getGeomCoeff(var)
@@ -143,9 +145,9 @@ class CellTerm(_NonDiffusionTerm):
 
     def _buildMatrixNoInline_(self, L, oldArray, b, dt, coeffVectors):            
         ids = self._reshapeIDs(oldArray, numerix.arange(oldArray.shape[-1]))
-        b += (oldArray.value[numerix.newaxis] * coeffVectors['old value']).sum(-2).ravel() / dt
+        b += old_div((oldArray.value[numerix.newaxis] * coeffVectors['old value']).sum(-2).ravel(), dt)
         b += coeffVectors['b vector'][numerix.newaxis].sum(-2).ravel()
-        L.addAt(coeffVectors['new value'].ravel() / dt, ids.ravel(), ids.swapaxes(0,1).ravel())
+        L.addAt(old_div(coeffVectors['new value'].ravel(), dt), ids.ravel(), ids.swapaxes(0,1).ravel())
         L.addAt(coeffVectors['diagonal'].ravel(), ids.ravel(), ids.swapaxes(0,1).ravel())
             
     def _buildMatrix(self, var, SparseMatrix, boundaryConditions=(), dt=None, transientGeomCoeff=None, diffusionGeomCoeff=None):
diff --git a/fipy/terms/explicitUpwindConvectionTerm.py b/fipy/terms/explicitUpwindConvectionTerm.py
index a4bf6cb..ba22537 100644
--- a/fipy/terms/explicitUpwindConvectionTerm.py
+++ b/fipy/terms/explicitUpwindConvectionTerm.py
@@ -61,7 +61,7 @@ class ExplicitUpwindConvectionTerm(_AbstractUpwindConvectionTerm):
 
     def _getWeight(self, var, transientGeomCoeff=None, diffusionGeomCoeff=None):
         weight = _AbstractUpwindConvectionTerm._getWeight(self, var, transientGeomCoeff, diffusionGeomCoeff)
-        if 'implicit' in weight.keys():
+        if 'implicit' in list(weight.keys()):
             weight['explicit'] = weight['implicit']
             del weight['implicit']
 
diff --git a/fipy/terms/exponentialConvectionTerm.py b/fipy/terms/exponentialConvectionTerm.py
index cfdcbeb..d4cc76d 100644
--- a/fipy/terms/exponentialConvectionTerm.py
+++ b/fipy/terms/exponentialConvectionTerm.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -66,9 +68,9 @@ class _ExponentialConvectionTermAlpha(FaceVariable):
         P  = self.P.numericValue
 
         P = numerix.where(abs(P) < eps, eps, P)
-        alpha = numerix.where(P > largeValue, (P - 1) / P, 0.5)
+        alpha = numerix.where(P > largeValue, old_div((P - 1), P), 0.5)
         Pmin = numerix.where(P > largeValue + 1, largeValue + 1, P)
-        alpha = numerix.where((abs(Pmin) > eps) & (Pmin <= largeValue), ((Pmin - 1) * numerix.exp(Pmin) + 1) / (Pmin * (numerix.exp(Pmin) - 1)), alpha)
+        alpha = numerix.where((abs(Pmin) > eps) & (Pmin <= largeValue), old_div(((Pmin - 1) * numerix.exp(Pmin) + 1), (Pmin * (numerix.exp(Pmin) - 1))), alpha)
 
         return alpha
 
diff --git a/fipy/terms/faceTerm.py b/fipy/terms/faceTerm.py
index 558fab9..ddb2023 100644
--- a/fipy/terms/faceTerm.py
+++ b/fipy/terms/faceTerm.py
@@ -1,3 +1,4 @@
+from builtins import input
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -49,7 +50,7 @@ class FaceTerm(_NonDiffusionTerm):
     """
     def __init__(self, coeff=1., var=None):
         if self.__class__ is FaceTerm:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         _NonDiffusionTerm.__init__(self, coeff=coeff, var=var)
         self.coeffMatrix = None
@@ -86,7 +87,7 @@ class FaceTerm(_NonDiffusionTerm):
                 self._viewer.title = r"%s %s" % (boundaryCondition.__class__.__name__, self.__class__.__name__)
                 self._viewer.plot(matrix=LL, RHSvector=bb)
                 from fipy import raw_input
-                raw_input()
+                input()
                     
             L += LL
             b += bb
diff --git a/fipy/terms/firstOrderAdvectionTerm.py b/fipy/terms/firstOrderAdvectionTerm.py
index 4fcde38..39c5e8e 100644
--- a/fipy/terms/firstOrderAdvectionTerm.py
+++ b/fipy/terms/firstOrderAdvectionTerm.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = ['FirstOrderAdvectionTerm']
@@ -151,7 +153,7 @@ class FirstOrderAdvectionTerm(_NonDiffusionTerm):
         return (var, SparseMatrix(mesh=var.mesh), -coeffXdifferences * mesh.cellVolumes)
 
     def _getDifferences(self, adjacentValues, cellValues, oldArray, cellToCellIDs, mesh):
-        return (adjacentValues - cellValues) / mesh._cellToCellDistances
+        return old_div((adjacentValues - cellValues), mesh._cellToCellDistances)
         
     def _getDefaultSolver(self, var, solver, *args, **kwargs):
         solver = solver or super(FirstOrderAdvectionTerm, self)._getDefaultSolver(var, solver, *args, **kwargs)
diff --git a/fipy/terms/hybridConvectionTerm.py b/fipy/terms/hybridConvectionTerm.py
index 7e4df35..8aa247d 100644
--- a/fipy/terms/hybridConvectionTerm.py
+++ b/fipy/terms/hybridConvectionTerm.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -51,9 +53,9 @@ class _HybridConvectionTermAlpha(FaceVariable):
         eps = 1e-3
         P  = self.P
 
-        alpha = numerix.where(                                 P > 2., (P - 1) / P,    0.)
+        alpha = numerix.where(                                 P > 2., old_div((P - 1), P),    0.)
         alpha = numerix.where( numerix.logical_and(2. >= P, P >= -2.),         0.5, alpha)
-        alpha = numerix.where(                               -2. >  P,      -1 / P, alpha)
+        alpha = numerix.where(                               -2. >  P,      old_div(-1, P), alpha)
 
         return alpha
 
diff --git a/fipy/terms/powerLawConvectionTerm.py b/fipy/terms/powerLawConvectionTerm.py
index 2474eec..f992fe1 100644
--- a/fipy/terms/powerLawConvectionTerm.py
+++ b/fipy/terms/powerLawConvectionTerm.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.terms.asymmetricConvectionTerm import _AsymmetricConvectionTerm
@@ -99,17 +101,17 @@ class _PowerLawConvectionTermAlpha(FaceVariable):
             P = self.P.numericValue
             P = numerix.where(abs(P) < eps, eps, P)
 
-            alpha = numerix.where(                  P > 10.,                     (P - 1.) / P,   0.5)
+            alpha = numerix.where(                  P > 10.,                     old_div((P - 1.), P),   0.5)
 
-            tmp = (1. - P / 10.)
+            tmp = (1. - old_div(P, 10.))
             tmpSqr = tmp * tmp
-            alpha = numerix.where(  (10. >= P) & (P > eps), ((P-1.) + tmpSqr*tmpSqr*tmp) / P, alpha)
+            alpha = numerix.where(  (10. >= P) & (P > eps), old_div(((P-1.) + tmpSqr*tmpSqr*tmp), P), alpha)
 
-            tmp = (1. + P / 10.)
+            tmp = (1. + old_div(P, 10.))
             tmpSqr = tmp * tmp
-            alpha = numerix.where((-eps >  P) & (P >= -10.),     (tmpSqr*tmpSqr*tmp - 1.) / P, alpha)
+            alpha = numerix.where((-eps >  P) & (P >= -10.),     old_div((tmpSqr*tmpSqr*tmp - 1.), P), alpha)
 
-            alpha = numerix.where(                 P < -10.,                          -1. / P, alpha)
+            alpha = numerix.where(                 P < -10.,                          old_div(-1., P), alpha)
 
             return PhysicalField(value = alpha)
 
diff --git a/fipy/terms/term.py b/fipy/terms/term.py
index 47f1069..8e41e1f 100644
--- a/fipy/terms/term.py
+++ b/fipy/terms/term.py
@@ -32,6 +32,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import input
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -176,7 +180,7 @@ class Term(object):
                 RHSvector = solver.RHSvector
             self._viewer.plot(matrix=solver.matrix, RHSvector=RHSvector)
             from fipy import raw_input            
-            raw_input()
+            input()
             
         return solver
     
@@ -414,7 +418,7 @@ class Term(object):
     __rmul__ = __mul__
 
     def __truediv__(self, other):
-        return (1 / other) * self
+        return (old_div(1, other)) * self
 
     __div__ = __truediv__
     
@@ -425,7 +429,7 @@ class Term(object):
         elif other == 0:
             return self
         else:
-            raise Exception, "Can only couple Term objects."
+            raise Exception("Can only couple Term objects.")
             
     __rand__ = __and__
 
diff --git a/fipy/terms/transientTerm.py b/fipy/terms/transientTerm.py
index 6c83e36..6636562 100644
--- a/fipy/terms/transientTerm.py
+++ b/fipy/terms/transientTerm.py
@@ -153,9 +153,9 @@ class TransientTerm(CellTerm):
 
     def _checkDt(self, dt):
         if dt is None:
-            raise TypeError, "`dt` must be specified."
+            raise TypeError("`dt` must be specified.")
         if numerix.getShape(dt) != ():
-            raise TypeError, "`dt` must be a single number, not a " + type(dt).__name__
+            raise TypeError("`dt` must be a single number, not a " + type(dt).__name__)
         return float(dt)
 
     def _test(self):
diff --git a/fipy/terms/unaryTerm.py b/fipy/terms/unaryTerm.py
index 15c2cbe..8e69995 100644
--- a/fipy/terms/unaryTerm.py
+++ b/fipy/terms/unaryTerm.py
@@ -1,3 +1,4 @@
+from builtins import input
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -114,7 +115,7 @@ class _UnaryTerm(Term):
              and "terms" in os.environ['FIPY_DISPLAY_MATRIX'].lower().split()): 
              self._viewer.title = "%s %s" % (var.name, repr(self))
              self._viewer.plot(matrix=matrix, RHSvector=RHSvector) 
-             raw_input()
+             input()
              
         return (var, matrix, RHSvector)
 
diff --git a/fipy/terms/vanLeerConvectionTerm.py b/fipy/terms/vanLeerConvectionTerm.py
index 4c4fbef..4790cba 100644
--- a/fipy/terms/vanLeerConvectionTerm.py
+++ b/fipy/terms/vanLeerConvectionTerm.py
@@ -36,6 +36,8 @@
 
 """
 """
+from __future__ import division
+from past.utils import old_div
 
 __docformat__ = 'restructuredtext'
 
@@ -73,7 +75,7 @@ class VanLeerConvectionTerm(ExplicitUpwindConvectionTerm):
         # Courant-Friedrichs-Levy number
         interiorCFL = abs(numerix.take(self._getGeomCoeff(oldArray), interiorIDs)) * dt
         
-        gradUpwind = (oldArray2 - oldArray1) / numerix.take(mesh._cellDistances, interiorIDs)
+        gradUpwind = old_div((oldArray2 - oldArray1), numerix.take(mesh._cellDistances, interiorIDs))
         
         vol1 = numerix.take(mesh.cellVolumes, id1)
         
diff --git a/fipy/tests/doctestPlus.py b/fipy/tests/doctestPlus.py
index 115ad21..5073b92 100644
--- a/fipy/tests/doctestPlus.py
+++ b/fipy/tests/doctestPlus.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -78,7 +80,7 @@ def execButNoTest(name='__main__'):
         raise ValueError("no tests found")
 
     for t in tests:
-        exec t
+        exec(t)
     
 _doctestSkippers = list()
 
@@ -116,11 +118,11 @@ def report_skips():
             skips.append("Skipped %d doctest examples because %s" 
                          % (len(skipper.skipped), skipper.why))
     if len(skips) > 0:
-        print >>sys.stderr, "!" * 79
-        print >>sys.stderr, "\n".join(skips)
-        print >>sys.stderr, "!" * 79
+        print("!" * 79, file=sys.stderr)
+        print("\n".join(skips), file=sys.stderr)
+        print("!" * 79, file=sys.stderr)
     
-class _DoctestSkipper:
+class _DoctestSkipper(object):
     def __init__(self, flag, test, why, skipWarning):
         self.flag = flag
         self.why = why
diff --git a/fipy/tests/testBase.py b/fipy/tests/testBase.py
index a59f23b..53d55b4 100644
--- a/fipy/tests/testBase.py
+++ b/fipy/tests/testBase.py
@@ -47,13 +47,13 @@ class _TestBase(unittest.TestCase):
 	"""Fail if the two objects are unequal by more than tol.
 	"""
 	if abs(first - second) > tol:
-	    raise self.failureException, (msg or '%s !~ %s' % (first, second))
+	    raise self.failureException(msg or '%s !~ %s' % (first, second))
         
     def assertArrayWithinTolerance(self, first, second, atol = 1e-10, rtol = 1e-10, msg=None):
 	"""Fail if the two objects are unequal by more than tol.
 	"""
 	if not numerix.allclose(first, second, rtol = rtol, atol = atol):
-	    raise self.failureException, (msg or '\n%s\nis not\n%s' % (first, second))
+	    raise self.failureException(msg or '\n%s\nis not\n%s' % (first, second))
 
     def testResult(self):
         pass
diff --git a/fipy/tests/testClass.py b/fipy/tests/testClass.py
index 109f0d9..5f16916 100644
--- a/fipy/tests/testClass.py
+++ b/fipy/tests/testClass.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import str
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -105,13 +107,13 @@ def _TestClass(base):
             
                 
             if self.viewers:
-                print "*" * 60
-                print "*" + "".center(58) + "*"
-                print "*" + "ATTENTION".center(58) + "*"
-                print "*" + "".center(58) + "*"
-                print "*" + "Some of the following tests require user interaction".center(58) + "*"
-                print "*" + "".center(58) + "*"
-                print "*" * 60
+                print("*" * 60)
+                print("*" + "".center(58) + "*")
+                print("*" + "ATTENTION".center(58) + "*")
+                print("*" + "".center(58) + "*")
+                print("*" + "Some of the following tests require user interaction".center(58) + "*")
+                print("*" + "".center(58) + "*")
+                print("*" * 60)
                 
                 self.test_args.append("fipy.viewers.testinteractive._suite")
 
@@ -133,50 +135,50 @@ def _TestClass(base):
                     mod = __import__(pkg)
                     
                     if hasattr(mod, '__version__'):
-                        print pkg,'version',mod.__version__
+                        print(pkg,'version',mod.__version__)
                     else:
-                        print pkg,'version not available'
+                        print(pkg,'version not available')
                         
-                except ImportError, e:
-                    print pkg,'is not installed'
+                except ImportError as e:
+                    print(pkg,'is not installed')
                     
-                except Exception, e:
-                    print pkg, 'version check failed:', e
+                except Exception as e:
+                    print(pkg, 'version check failed:', e)
 
             ## PyTrilinos
             try:
                 import PyTrilinos
-                print PyTrilinos.version()
-            except ImportError, e:
-                print pkg,'is not installed'
-            except Exception, e:
-                print pkg, 'version check failed:', e
+                print(PyTrilinos.version())
+            except ImportError as e:
+                print(pkg,'is not installed')
+            except Exception as e:
+                print(pkg, 'version check failed:', e)
 
             ## Mayavi uses a non-standard approach for storing its version nummber.
             try:
                 from mayavi.__version__ import __version__ as mayaviversion
-                print 'mayavi version', mayaviversion
-            except ImportError, e:
+                print('mayavi version', mayaviversion)
+            except ImportError as e:
                 try:
                     from enthought.mayavi.__version__ import __version__ as mayaviversion
-                    print 'enthought.mayavi version', mayaviversion
-                except ImportError, e:
-                    print 'enthought.mayavi is not installed'       
-                except Exception, e:
-                    print 'enthought.mayavi version check failed:', e
-            except Exception, e:
-                print 'mayavi version check failed:', e
+                    print('enthought.mayavi version', mayaviversion)
+                except ImportError as e:
+                    print('enthought.mayavi is not installed')       
+                except Exception as e:
+                    print('enthought.mayavi version check failed:', e)
+            except Exception as e:
+                print('mayavi version check failed:', e)
 
             ## Gmsh version
             try:
                 from fipy.meshes.gmshMesh import gmshVersion
                 gmshversion = gmshVersion()
                 if gmshversion is None:
-                    print 'gmsh is not installed'
+                    print('gmsh is not installed')
                 else:
-                    print 'gmsh version',gmshversion
-            except Exception, e:
-                print 'gmsh version check failed:', e
+                    print('gmsh version',gmshversion)
+            except Exception as e:
+                print('gmsh version check failed:', e)
 
         def run_tests(self):
             import sys
@@ -192,15 +194,15 @@ def _TestClass(base):
                     except:
                         pass
                     import PyTrilinos
-                except ImportError, a:
-                    print >>sys.stderr, "!!! Trilinos library is not installed"
+                except ImportError as a:
+                    print("!!! Trilinos library is not installed", file=sys.stderr)
                     return
 
             if self.inline:
                 try:
                     from scipy import weave
-                except ImportError, a:
-                    print >>sys.stderr, "!!! weave library is not installed"
+                except ImportError as a:
+                    print("!!! weave library is not installed", file=sys.stderr)
                     return
                     
             if self.pythoncompiled is not None:
@@ -219,7 +221,7 @@ def _TestClass(base):
                     None, None, [unittest.__file__]+self.test_args,
                     testLoader = loader_class()
                     )
-            except SystemExit, exitErr:
+            except SystemExit as exitErr:
                 # unittest.main(..., exit=...) not available until Python 2.7
                 from fipy.tests.doctestPlus import report_skips
                 report_skips()
diff --git a/fipy/tests/testProgram.py b/fipy/tests/testProgram.py
index 6903d1d..26a54be 100644
--- a/fipy/tests/testProgram.py
+++ b/fipy/tests/testProgram.py
@@ -73,7 +73,7 @@ class _TestProgram(unittest.TestProgram):
 ##              argv[1:] = ['--inline']
 ##            if numMesh:
 ##                argv[1:] = ['--numMesh']
-        except getopt.error, msg:
+        except getopt.error as msg:
             self.usageExit(msg)
 
 main = _TestProgram
diff --git a/fipy/tools/__init__.py b/fipy/tools/__init__.py
index eb4d3cd..5a74729 100644
--- a/fipy/tools/__init__.py
+++ b/fipy/tools/__init__.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+from builtins import range
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -112,7 +114,7 @@ for M in (2, 3):
 import fipy.tools.dump
 import fipy.tools.numerix
 import fipy.tools.vector
-from dimensions.physicalField import PhysicalField
+from .dimensions.physicalField import PhysicalField
 from fipy.tools.numerix import *
 from fipy.tools.vitals import Vitals
 
diff --git a/fipy/tools/comms/commWrapper.py b/fipy/tools/comms/commWrapper.py
index 6b5aedc..dde9e5b 100644
--- a/fipy/tools/comms/commWrapper.py
+++ b/fipy/tools/comms/commWrapper.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/tools/copy_script.py b/fipy/tools/copy_script.py
index f12293b..2200b6c 100644
--- a/fipy/tools/copy_script.py
+++ b/fipy/tools/copy_script.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import input
 ## -*-Pyth-*-
  # ###################################################################
  #  FiPy - Python-based finite volume PDE solver
@@ -65,13 +67,13 @@ class Copy_script(Command):
             ans = "junk"
             
             while (len(ans) > 0) and ("yes".find(ans.lower()) is not 0) and ("no".find(ans.lower()) is not 0):
-                ans = raw_input("The file '%s' already exists. Overwrite? [n] "%self.To)
+                ans = input("The file '%s' already exists. Overwrite? [n] "%self.To)
                 
             if ans is '':
                 ans = 'no'
                 
             if ("no".find(ans.lower()) is 0):
-                self.To = raw_input("Please give a name for the ouput file: ")
+                self.To = input("Please give a name for the ouput file: ")
                 self.finalize_options()
 
     def run(self):
@@ -85,4 +87,4 @@ class Copy_script(Command):
         f.write(script)
         f.close()
         
-        print "Script code exported from '%s' to '%s'"%(self.From, self.To)
+        print("Script code exported from '%s' to '%s'"%(self.From, self.To))
diff --git a/fipy/tools/debug.py b/fipy/tools/debug.py
index ea4be2c..605e909 100644
--- a/fipy/tools/debug.py
+++ b/fipy/tools/debug.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import range
 __all__ = ["PRINT"]
 
 def PRINT(label, arg="", stall=True):
@@ -7,7 +9,7 @@ def PRINT(label, arg="", stall=True):
     
     for procID in range(parallelComm.Nproc):
         if procID == parallelComm.procID:
-            print >>sys.stderr, parallelComm.procID, label, arg
+            print(parallelComm.procID, label, arg, file=sys.stderr)
         sys.stderr.flush()
         if stall:
             time.sleep(0.1)
diff --git a/fipy/tools/decorators.py b/fipy/tools/decorators.py
index d7db7a9..1740b16 100644
--- a/fipy/tools/decorators.py
+++ b/fipy/tools/decorators.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -78,8 +79,8 @@ if sys.version_info < (2, 4):
     # Can't set __name__ in 2.3
     import new
     def _set_function_name(func, name):
-        func = new.function(func.func_code, func.func_globals,
-                            name, func.func_defaults, func.func_closure)
+        func = new.function(func.__code__, func.__globals__,
+                            name, func.__defaults__, func.__closure__)
         return func
 else:
     def _set_function_name(func, name):
@@ -114,7 +115,7 @@ class _Deprecate(object):
         old_name = self.old_name
         if old_name is None:
             try:
-                old_name = func.func_name
+                old_name = func.__name__
             except AttributeError:
                 old_name = func.__name__
         return old_name
diff --git a/fipy/tools/dimensions/NumberDict.py b/fipy/tools/dimensions/NumberDict.py
index 3b14bf2..5deb0cc 100644
--- a/fipy/tools/dimensions/NumberDict.py
+++ b/fipy/tools/dimensions/NumberDict.py
@@ -1,3 +1,4 @@
+from builtins import str
 # Dictionary containing numbers
 #
 # These objects are meant to be used like arrays with generalized
@@ -43,9 +44,9 @@ class _NumberDict(DictWithDefault._DictWithDefault):
 
     def __add__(self, other):
         sum = _NumberDict()
-        for key in self.keys():
+        for key in list(self.keys()):
             sum[key] = self[key]
-        for key in other.keys():
+        for key in list(other.keys()):
             sum[key] = sum[key] + other[key]
         return sum
 
@@ -53,9 +54,9 @@ class _NumberDict(DictWithDefault._DictWithDefault):
 
     def __sub__(self, other):
         sum = _NumberDict()
-        for key in self.keys():
+        for key in list(self.keys()):
             sum[key] = self[key]
-        for key in other.keys():
+        for key in list(other.keys()):
             sum[key] = sum[key] - other[key]
         return sum
 
@@ -70,7 +71,7 @@ class _NumberDict(DictWithDefault._DictWithDefault):
 
     def __mul__(self, other):
         new = _NumberDict()
-        for key in self.keys():
+        for key in list(self.keys()):
             new[key] = other*self[key]
         return new
 
@@ -78,7 +79,7 @@ class _NumberDict(DictWithDefault._DictWithDefault):
 
     def __floordiv__(self, other):
         new = _NumberDict()
-        for key in self.keys():
+        for key in list(self.keys()):
             new[key] = self[key]//other
         return new
 
diff --git a/fipy/tools/dimensions/physicalField.py b/fipy/tools/dimensions/physicalField.py
index 92a231d..1d93408 100755
--- a/fipy/tools/dimensions/physicalField.py
+++ b/fipy/tools/dimensions/physicalField.py
@@ -93,6 +93,13 @@ recommended values from CODATA_. Other conversion factors
 .. _CODATA:                                     http://www.codata.org/
 .. _Appendix B of NIST Special Publication 811: http://physics.nist.gov/Pubs/SP811/appenB9.html
 """
+from __future__ import division
+from builtins import map
+from builtins import str
+from builtins import range
+from builtins import object
+from past.utils import old_div
+from functools import reduce
 __docformat__ = 'restructuredtext'
 
 import re
@@ -315,7 +322,7 @@ class PhysicalField(object):
             elif self.unit.isDimensionlessOrAngle() or self.unit.isInverseAngle():
                 new_value = sign1(selfValue) + sign2(other)
             else:
-                raise TypeError, str(self) + ' and ' + str(other) + ' are incompatible.'
+                raise TypeError(str(self) + ' and ' + str(other) + ' are incompatible.')
         else:
             new_value = (sign1(selfValue)
                          + sign2(other.value) * other.unit.conversionFactorTo(self.unit))
@@ -418,11 +425,11 @@ class PhysicalField(object):
         if type(other) is type(''):
             other = self.__class__(value = other)
         if not isinstance(other,PhysicalField):
-            value = self.value/other 
+            value = old_div(self.value,other) 
             unit = self.unit
         else:
-            value = self.value/other.value
-            unit = self.unit/other.unit
+            value = old_div(self.value,other.value)
+            unit = old_div(self.unit,other.unit)
         if unit.isDimensionless():
             return value*unit.factor
         else:
@@ -437,11 +444,11 @@ class PhysicalField(object):
         if type(other) is type(''):
             other = PhysicalField(value = other)
         if not isinstance(other,PhysicalField):
-            value = other/self.value
+            value = old_div(other,self.value)
             unit = pow(self.unit, -1)
         else:
-            value = other.value/self.value
-            unit = other.unit/self.unit
+            value = old_div(other.value,self.value)
+            unit = old_div(other.unit,self.unit)
         if unit.isDimensionless():
             return value*unit.factor
         else:
@@ -466,7 +473,7 @@ class PhysicalField(object):
             unit = self.unit
         else:
             value = self.value % other.value
-            unit = self.unit/other.unit
+            unit = old_div(self.unit,other.unit)
         if unit.isDimensionless():
             return value*unit.factor
         else:
@@ -520,7 +527,7 @@ class PhysicalField(object):
         """
         return numerix.sign(self.value)
 
-    def __nonzero__(self):
+    def __bool__(self):
         """
         Test if the quantity is zero. 
         
@@ -538,7 +545,7 @@ class PhysicalField(object):
             elif numerix.alltrue(other == 0) or self.unit.isDimensionlessOrAngle():
                 other = PhysicalField(value = other, unit = self.unit)
             else:
-                raise TypeError, 'Incompatible units'
+                raise TypeError('Incompatible units')
         return other.inUnitsOf(self.unit)
         
     def __getitem__(self, index): 
@@ -693,7 +700,7 @@ class PhysicalField(object):
         if self.unit.isDimensionlessOrAngle():
             return self.value
         else:
-            raise TypeError, 'Numeric array value must be dimensionless'
+            raise TypeError('Numeric array value must be dimensionless')
 	
     def __float__(self):
         """
@@ -727,7 +734,7 @@ class PhysicalField(object):
         if self.unit.isDimensionlessOrAngle():
             return float(self.numericValue)
         else:
-            raise TypeError, 'Not possible to convert a PhysicalField with dimensions to float'
+            raise TypeError('Not possible to convert a PhysicalField with dimensions to float')
                     
     def __gt__(self,other):
         """
@@ -863,7 +870,7 @@ class PhysicalField(object):
         if self.unit.isDimensionless():
             return self.value
         else:
-            raise TypeError, 'Incompatible units'
+            raise TypeError('Incompatible units')
 
     def inUnitsOf(self, *units):
         """
@@ -890,7 +897,7 @@ class PhysicalField(object):
         ...                        True)
         1
         """
-        units = map(_findUnit, units)
+        units = list(map(_findUnit, units))
         if len(units) == 1:
             unit = units[0]
             value = _convertValue (self.value, self.unit, unit)
@@ -978,7 +985,7 @@ class PhysicalField(object):
             new_value = self.value
         num = ''
         denom = ''
-        for i in xrange(9):
+        for i in range(9):
             unit = _base_names[i]
             power = self.unit.powers[i]
             if power < 0:
@@ -1416,7 +1423,7 @@ class PhysicalField(object):
         other = self._inMyUnits(other)
         return MA.allequal(self.value, other.value)
 
-class PhysicalUnit:
+class PhysicalUnit(object):
     """
     A `PhysicalUnit` represents the units of a `PhysicalField`.
     """
@@ -1461,9 +1468,9 @@ class PhysicalUnit:
             if other == 1:
                 return self.isDimensionless()
             else:
-                raise TypeError, 'PhysicalUnits can only be compared with other PhysicalUnits'
+                raise TypeError('PhysicalUnits can only be compared with other PhysicalUnits')
         if not numerix.alltrue(self.powers == other.powers):
-            raise TypeError, 'Incompatible units'
+            raise TypeError('Incompatible units')
 
     def __eq__(self, other):
         """
@@ -1540,7 +1547,7 @@ class PhysicalUnit:
             <PhysicalUnit kB*K>
         """
         if self.offset != 0 or (isinstance(other,PhysicalUnit) and other.offset != 0):
-            raise TypeError, "cannot multiply units with non-zero offset"
+            raise TypeError("cannot multiply units with non-zero offset")
         if isinstance(other,PhysicalUnit):
             return PhysicalUnit(self.names+other.names,
                                 self.factor*other.factor,
@@ -1587,14 +1594,14 @@ class PhysicalUnit:
             <PhysicalUnit J/K>
         """
         if self.offset != 0 or (isinstance(other,PhysicalUnit) and other.offset != 0):
-            raise TypeError, "cannot divide units with non-zero offset"
+            raise TypeError("cannot divide units with non-zero offset")
         if isinstance(other,PhysicalUnit):
             return PhysicalUnit(self.names-other.names,
-                                self.factor/other.factor,
+                                old_div(self.factor,other.factor),
                                 self.powers - other.powers)
         else:
             return PhysicalUnit(self.names+{str(other): -1},
-                                self.factor/other, self.powers)
+                                old_div(self.factor,other), self.powers)
 
     __div__ = __truediv__
     
@@ -1617,15 +1624,15 @@ class PhysicalUnit:
             <PhysicalUnit 3.0/K>
         """
         if self.offset != 0 or (isinstance(other,PhysicalUnit) and other.offset != 0):
-            raise TypeError, "cannot divide units with non-zero offset"
+            raise TypeError("cannot divide units with non-zero offset")
         if isinstance(other,PhysicalUnit):
             return PhysicalUnit(other.names-self.names,
-                                other.factor/self.factor,
-                                map(lambda a,b: a-b,
-                                    other.powers, self.powers))
+                                old_div(other.factor,self.factor),
+                                list(map(lambda a,b: a-b,
+                                    other.powers, self.powers)))
         else:
             return PhysicalUnit({str(other): 1}-self.names,
-                                other/self.factor,
+                                old_div(other,self.factor),
                                 -self.powers)
                                 
     __rdiv__ = __rtruediv__
@@ -1658,7 +1665,7 @@ class PhysicalUnit:
             <PhysicalUnit K**2>
         """
         if self.offset != 0:
-            raise TypeError, "cannot exponentiate units with non-zero offset"
+            raise TypeError("cannot exponentiate units with non-zero offset")
         if type(other) == type(0):
             return PhysicalUnit(other*self.names, pow(self.factor, other),
                                 self.powers*other)
@@ -1671,15 +1678,15 @@ class PhysicalUnit:
             return PhysicalUnit(other*self.names, pow(self.factor, other),
                                 self.powers*other)
 
-        inv_exp = 1./other
+        inv_exp = old_div(1.,other)
         rounded = int(umath.floor(inv_exp+0.5))
         if abs(inv_exp-rounded) < 1.e-10:
             if numerix.logical_and.reduce(self.powers % rounded == 0):
                 f = pow(self.factor, other)
                 p = self.powers // rounded
                 if reduce(lambda a, b: a and b,
-                          map(lambda x, e=rounded: x%e == 0,
-                              self.names.values())):
+                          list(map(lambda x, e=rounded: x%e == 0,
+                              list(self.names.values())))):
                     names = self.names // rounded
                 else:
                     names = _NumberDict()
@@ -1689,8 +1696,8 @@ class PhysicalUnit:
                         names[_base_names[i]] = p[i]
                 return PhysicalUnit(names, f, p)
             else:
-                raise TypeError, 'Illegal exponent'
-        raise TypeError, 'Only integer and inverse integer exponents allowed'
+                raise TypeError('Illegal exponent')
+        raise TypeError('Only integer and inverse integer exponents allowed')
 
     def conversionFactorTo(self, other):
         """
@@ -1722,15 +1729,14 @@ class PhysicalUnit:
         """
         if not numerix.alltrue(self.powers == other.powers):
             if self.isDimensionlessOrAngle() and other.isDimensionlessOrAngle():
-                return self.factor/other.factor
+                return old_div(self.factor,other.factor)
             else:
-                raise TypeError, 'Incompatible units'
+                raise TypeError('Incompatible units')
         if self.offset != other.offset and self.factor != other.factor:
-            raise TypeError, \
-                  ('Unit conversion (%s to %s) cannot be expressed ' +
+            raise TypeError(('Unit conversion (%s to %s) cannot be expressed ' +
                    'as a simple multiplicative factor') % \
-                  (self.name(), other.name())
-        return self.factor/other.factor
+                  (self.name(), other.name()))
+        return old_div(self.factor,other.factor)
 
     def conversionTupleTo(self, other): # added 1998/09/29 GPW
         """
@@ -1742,7 +1748,7 @@ class PhysicalUnit:
             ['0.555556', '459.67']
         """
         if not numerix.alltrue(self.powers == other.powers):
-            raise TypeError, 'Incompatible units'
+            raise TypeError('Incompatible units')
 
         # let (s1,d1) be the conversion tuple from 'self' to base units
         #   (ie. (x+d1)*s1 converts a value x from 'self' to base units,
@@ -1759,7 +1765,7 @@ class PhysicalUnit:
         #   = ( (x+d1) - (d1*s2/s1) ) * s1/s2
         #   = (x + d1 - d2*s2/s1) * s1/s2
         # thus, D = d1 - d2*s2/s1 and S = s1/s2
-        factor = self.factor / other.factor
+        factor = old_div(self.factor, other.factor)
         offset = self.offset - (other.offset * other.factor / self.factor)
         return (factor, offset)
 
@@ -1862,7 +1868,7 @@ class PhysicalUnit:
         """
         num = ''
         denom = ''
-        for unit in self.names.keys():
+        for unit in list(self.names.keys()):
             power = self.names[unit]
             if power < 0:
                 denom = denom + '/' + unit
@@ -1913,7 +1919,7 @@ def _findUnit(unit):
         if unit == 1:
             unit = _unity
         else:
-            raise TypeError, str(unit) + ' is not a unit'
+            raise TypeError(str(unit) + ' is not a unit')
     return unit
 
 def _round(x):
@@ -1960,16 +1966,16 @@ def _Scale(quantity, scaling):
         scaling = PhysicalField(scaling)
         # normalize quantity to scaling
         # error will be thrown if incompatible
-        dimensionless = quantity / scaling
+        dimensionless = old_div(quantity, scaling)
     else:
         # Assume quantity is a dimensionless number and return it.
         # Automatically throws an error if it's not a number.
         dimensionless = quantity
                 
     if isinstance(dimensionless,PhysicalField) and not dimensionless.unit.isDimensionless():
-        raise TypeError, repr(quantity.inBaseUnits().unit) + ' and ' \
+        raise TypeError(repr(quantity.inBaseUnits().unit) + ' and ' \
         + repr(scaling.inBaseUnits().unit) \
-        + ' are incompatible'
+        + ' are incompatible')
         
     return dimensionless
   
@@ -2021,7 +2027,7 @@ for unit in _base_units:
 
 def _addUnit(name, unit):
     if name in _unit_table:
-        raise KeyError, 'Unit ' + name + ' already defined'
+        raise KeyError('Unit ' + name + ' already defined')
     if type(unit) == type(''):
         unit = eval(unit, _unit_table)
         for cruft in ['__builtins__', '__args__']:
@@ -2061,7 +2067,7 @@ _addUnit('Sv', 'J/kg')               # Sievert
 
 del _unit_table['kg']
 
-for unit in _unit_table.keys():
+for unit in list(_unit_table.keys()):
     _addPrefixed(unit)
 
 # Fundamental constants
@@ -2168,7 +2174,7 @@ _addUnit('deg', 'pi*rad/180')        # degrees
 kelvin = _findUnit ('K')
 _addUnit ('degR', '(5./9.)*K')       # degrees Rankine
 _addUnit ('degC', PhysicalUnit (None, 1.0, kelvin.powers, 273.15))
-_addUnit ('degF', PhysicalUnit (None, 5./9., kelvin.powers, 459.67))
+_addUnit ('degF', PhysicalUnit (None, old_div(5.,9.), kelvin.powers, 459.67))
 del kelvin
 
 _unity = eval("m/m", _unit_table)
@@ -2179,7 +2185,7 @@ def _getUnitStrings():
     
     def _getSortedUnitStrings(unitDict):
         strings = []
-        keys = unitDict.keys()
+        keys = list(unitDict.keys())
         keys.sort(key=str.lower)
         for key in keys:
             if key in unitDict:
@@ -2214,7 +2220,7 @@ def _getUnitStrings():
 
     units.append("\nUnits derived from SI (accepting SI prefixes)::\n")
     derived = {}
-    for key in working_table.keys():
+    for key in list(working_table.keys()):
         if key in working_table:
             unit = working_table[key]
             if isinstance(unit, PhysicalUnit) and unit.factor == 1:
@@ -2225,7 +2231,7 @@ def _getUnitStrings():
 
     units.append("\nOther units that accept SI prefixes::\n")
     prefixed = {}
-    for key in working_table.keys():
+    for key in list(working_table.keys()):
         if key in working_table:
             unit = working_table[key]
             isPrefixed = 1
diff --git a/fipy/tools/dump.py b/fipy/tools/dump.py
index e45dea1..3ae8793 100644
--- a/fipy/tools/dump.py
+++ b/fipy/tools/dump.py
@@ -1,3 +1,5 @@
+from future import standard_library
+standard_library.install_aliases()
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -36,7 +38,7 @@
 
 __docformat__ = 'restructuredtext'
 
-import cPickle
+import pickle
 import os
 import sys
 import gzip
@@ -80,7 +82,7 @@ def write(data, filename = None, extension = '', communicator=parallelComm):
         fileStream = open(os.devnull, mode='w')
         (f, _filename) = (None, os.devnull)
         
-    cPickle.dump(data, fileStream, 0)
+    pickle.dump(data, fileStream, 0)
     fileStream.close()
         
     if filename is None:
@@ -112,13 +114,13 @@ def read(filename, fileobject=None, communicator=parallelComm, mesh_unmangle=Fal
         data = communicator.bcast(data, root=0)
 
     if sys.version_info < (3,0):
-        import StringIO
-        f = StringIO.StringIO(data)
+        import io
+        f = io.StringIO(data)
     else:
         import io
         f = io.BytesIO(data)
         
-    unpickler = cPickle.Unpickler(f)
+    unpickler = pickle.Unpickler(f)
     
     if mesh_unmangle:
         def find_class(module, name):
@@ -129,7 +131,7 @@ def read(filename, fileobject=None, communicator=parallelComm, mesh_unmangle=Fal
             from fipy import meshes
             import types
             
-            if isinstance(klass, types.ClassType) and issubclass(klass, meshes.mesh.Mesh):
+            if isinstance(klass, type) and issubclass(klass, meshes.mesh.Mesh):
                 class UnmangledMesh(klass):
                     def __setstate__(self, dict):
                         if ('cellFaceIDs' in dict 
diff --git a/fipy/tools/inline.py b/fipy/tools/inline.py
index 5eb2216..f707476 100644
--- a/fipy/tools/inline.py
+++ b/fipy/tools/inline.py
@@ -1,3 +1,4 @@
+from builtins import range
 __all__ = ["doInline"]
 
 import inspect
@@ -65,7 +66,7 @@ def _operatorVariableComment(canInline=True, level=3):
         return ""
 
 def _runInline(code_in, converters=None, verbose=0, comment=None, **args):
-    argsKeys = args.keys()
+    argsKeys = list(args.keys())
     dimList = ['i', 'j', 'k']
           
     if 'ni' in argsKeys:
@@ -97,12 +98,12 @@ def _runInline(code_in, converters=None, verbose=0, comment=None, **args):
     
     from scipy import weave
 
-    for key in args.keys():
+    for key in list(args.keys()):
         if hasattr(args[key], 'dtype') and args[key].dtype.char == '?':
             args[key] = args[key].astype('B')
 
     weave.inline(code,
-                 args.keys(),
+                 list(args.keys()),
                  local_dict=args,
                  type_converters=None, #weave.converters.blitz,
                  compiler = 'gcc',
@@ -148,12 +149,12 @@ for(i=0; i < ni; i++) {
 
     from scipy import weave
 
-    for key in args.keys():
+    for key in list(args.keys()):
         if hasattr(args[key], 'dtype') and args[key].dtype.char == '?':
             args[key] = args[key].astype('B')
             
     weave.inline(code,
-                 args.keys(),
+                 list(args.keys()),
                  local_dict=args,
                  type_converters=None, #weave.converters.blitz,
                  compiler = 'gcc',
diff --git a/fipy/tools/numerix.py b/fipy/tools/numerix.py
index cbebcc0..e2aabc8 100644
--- a/fipy/tools/numerix.py
+++ b/fipy/tools/numerix.py
@@ -70,6 +70,12 @@ Take the tangent of an array.
    [ 0.  0.  0.]
    
 """
+from __future__ import division
+from __future__ import print_function
+from builtins import str
+from builtins import zip
+from builtins import range
+from past.utils import old_div
 
 __docformat__ = 'restructuredtext'
 
@@ -202,7 +208,7 @@ def reshape(arr, shape):
         newShape = array(left + right)
         newShape[newShape == 0] = 1
         
-        shape = left + (oldShape.prod() / newShape.prod(),) + right
+        shape = left + (old_div(oldShape.prod(), newShape.prod()),) + right
         
     if _isPhysical(arr):
         return arr.reshape(shape)
@@ -239,7 +245,7 @@ def getShape(arr):
     elif type(arr) in (type(1), type(1.)):
         return ()
     else:
-        raise AttributeError, "No attribute 'shape'"
+        raise AttributeError("No attribute 'shape'")
 
 def rank(a):
     """
@@ -364,7 +370,7 @@ def tostring(arr, max_line_width=75, precision=8, suppress_small=False, separato
             from numpy.core.arrayprint import _formatInteger
             return _formatInteger(arr, format='%d')
     else:        
-        raise TypeError, 'cannot convert ' + str(arr) + ' to string'
+        raise TypeError('cannot convert ' + str(arr) + ' to string')
         
 #########################
 #                       #
@@ -645,7 +651,7 @@ def take(a, indices, axis=0, fill_value=None):
     elif type(a) is type(MA.array((0))):
         taken = MA.take(a, indices, axis=axis)
     else:
-        raise TypeError, 'cannot take from %s object: %s' % (type(a), `a`)
+        raise TypeError('cannot take from %s object: %s' % (type(a), repr(a)))
                
     if fill_value is not None and type(taken) is type(MA.array((0))):
         taken = taken.filled(fill_value=fill_value)
@@ -686,7 +692,7 @@ def indices(dimensions, typecode=None):
         
 
 if not hasattr(NUMERIX, 'empty'):
-    print 'defining empty'
+    print('defining empty')
     if inline.doInline:
         def empty(shape, dtype='d', order='C'):
             """
@@ -746,7 +752,7 @@ while (return_val.refcount() > 1) {
 """
 
             return weave.inline(code,
-                         local_dict.keys(),
+                         list(local_dict.keys()),
                          local_dict=local_dict,
                          type_converters=weave.converters.blitz,
                          compiler='gcc',
@@ -880,7 +886,7 @@ if not (hasattr(NUMERIX, 'savetxt') and hasattr(NUMERIX, 'loadtxt')):
             vals = line.split(delimiter) 
             if converterseq is None: 
                converterseq = [converters.get(j,defconv) \
-                               for j in xrange(len(vals))] 
+                               for j in range(len(vals))] 
             if usecols is not None: 
                 row = [converterseq[j](vals[j]) for j in usecols] 
             else: 
@@ -999,7 +1005,7 @@ def _compressIndexSubspaces(index, i, broadcastshape = ()):
             
             broadcastshape = _broadcastShape(broadcastshape, element.shape)
             if broadcastshape is None:
-                raise ValueError, "shape mismatch: objects cannot be broadcast to a single shape"
+                raise ValueError("shape mismatch: objects cannot be broadcast to a single shape")
         skip += 1
 
     return broadcastshape, skip
@@ -1136,9 +1142,9 @@ def _indexShape(index, arrayShape):
         # "If the lenth of the selection tuple is larger than N (=X.ndim) an error 
         # is raised."
         if len(arrayShape) == 0:
-            raise IndexError, "0-d arrays can't be indexed"
+            raise IndexError("0-d arrays can't be indexed")
         else:
-            raise IndexError, "invalid index"
+            raise IndexError("invalid index")
     else:
         # "If the selection tuple is smaller than N, then as many ':' objects as
         # needed are added to the end of the selection tuple so that the modified 
@@ -1186,7 +1192,7 @@ def _indexShape(index, arrayShape):
             indexShape += ((stop - start) // stride,)
             j += 1
         else:
-            raise IndexError, "invalid index"
+            raise IndexError("invalid index")
                 
     if arrayindex is not None:
         indexShape = indexShape[:arrayindex] + broadcastshape + indexShape[arrayindex:]
diff --git a/fipy/tools/performance/efficiencyTestGenerator.py b/fipy/tools/performance/efficiencyTestGenerator.py
index 98bef14..b015215 100644
--- a/fipy/tools/performance/efficiencyTestGenerator.py
+++ b/fipy/tools/performance/efficiencyTestGenerator.py
@@ -34,6 +34,11 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import str
+from builtins import range
+from past.utils import old_div
 __all__ = []
 
 import os
@@ -49,7 +54,7 @@ def run(cases, elements):
     for i in range(len(cases)):
         if os.path.exists(toScripts[i]):
             os.remove(toScripts[i])
-        print 'Running on file', cases[i]
+        print('Running on file', cases[i])
         
         DocProg = Copy_script(dummyCommand)
         DocProg.From = cases[i]
@@ -93,11 +98,11 @@ def run(cases, elements):
                 elements = str(elements)
                 linelist = line.split('=')
                 dimensions = len(linelist)-1
-                root_elements = str(int(float(elements) ** (float(1)/dimensions)))
+                root_elements = str(int(float(elements) ** (old_div(float(1),dimensions))))
                 linelist.insert((len(linelist)-1), root_elements)
                 del linelist[len(linelist)-1]
                 newvalue = whitespaces * ' ' + '='.join(linelist) + '\n'
-                print 'newvalue:', newvalue
+                print('newvalue:', newvalue)
                 flist.insert(index, newvalue)
                 del flist[index+1]
             elif ('steps =' in line) or ('totalSteps =' in line):
diff --git a/fipy/tools/performance/efficiencyTestHistory.py b/fipy/tools/performance/efficiencyTestHistory.py
index 98fbb7d..b71a50a 100644
--- a/fipy/tools/performance/efficiencyTestHistory.py
+++ b/fipy/tools/performance/efficiencyTestHistory.py
@@ -1,3 +1,4 @@
+from __future__ import print_function
 ##This script runs on using "file", which is created with the command $svn log --xml --incremental > file
 ##Update file if there is a new revision to /trunk/examples. Otherwise you may ignore this.
 
@@ -62,9 +63,9 @@ def run(startRev):
     os.chdir("../../../trunk/examples")
     for k in revisions[index:3511]:
         revisionNumber = pysvn.Client().update(".", revision=pysvn.Revision(pysvn.opt_revision_kind.number, k))
-        print "pysvn.Client().info('.')['revision'].number: ", pysvn.Client().info('.')['revision'].number
+        print("pysvn.Client().info('.')['revision'].number: ", pysvn.Client().info('.')['revision'].number)
         os.chdir("../../efficiency_test")
-        print 'hello'
+        print('hello')
         test.run()
         os.wait()
         os.chdir("../trunk/examples")
diff --git a/fipy/tools/performance/efficiency_test.py b/fipy/tools/performance/efficiency_test.py
index b3df3b5..b37900a 100644
--- a/fipy/tools/performance/efficiency_test.py
+++ b/fipy/tools/performance/efficiency_test.py
@@ -1,3 +1,8 @@
+from __future__ import print_function
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
+from builtins import range
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -92,7 +97,7 @@ class Efficiency_test(Command):
         newCases = efficiencyTestGenerator.run(self.cases,self.newElements)
 
         for case in newCases:
-            print "case: %s" % case
+            print("case: %s" % case)
             
             if self.path is None:
                 testPath = os.path.split(case)[0]
@@ -116,21 +121,21 @@ class Efficiency_test(Command):
             
             numberOfElements = self.minimumelements
 
-            print "Running example:"
+            print("Running example:")
             cmd = ["python", "-W ignore", case]
 
             output = "\t".join([str(self.inline).center(10), str(self.cache).center(10),\
                                     (time.ctime()).center(25), str(numberOfElements).center(10)])
-            print 'cmd',cmd
+            print('cmd',cmd)
             w, r = os.popen2(cmd)
             
             outputlist= r.read().split()
-            print outputlist
+            print(outputlist)
             init_time = outputlist[outputlist.index('Initialization-time:')+1]
             frst_timestp = outputlist[outputlist.index('First-timestep:')+1]
             avg_timestp = outputlist[outputlist.index('Average-timestep:')+1]
             runtime = outputlist[outputlist.index('Runtime:')+1]
-            print "runtime: ", runtime
+            print("runtime: ", runtime)
             output += '\t' + ''.join(runtime).strip()
             r.close()
             w.close()
@@ -143,7 +148,7 @@ class Efficiency_test(Command):
                 f.flush()
  
             if self.uploadToCodespeed:
-                import urllib, urllib2
+                import urllib.request, urllib.parse, urllib.error, urllib.request, urllib.error, urllib.parse
                 import time 
                 import pysvn
                 from datetime import datetime
@@ -152,22 +157,22 @@ class Efficiency_test(Command):
 
                 revnum = pysvn.Client().info('.')['revision'].number
                 revdate  = pysvn.Client().info('.')['commit_time']                   
-                print 'revdate: ', datetime.fromtimestamp(revdate)
+                print('revdate: ', datetime.fromtimestamp(revdate))
 
                 def add(data):
-                    params = urllib.urlencode(data)
+                    params = urllib.parse.urlencode(data)
                     response = "None"
-                    print "Saving result for executable %s, revision %s, benchmark %s" % (
-                        data['executable'], data['commitid'], data['benchmark'])
+                    print("Saving result for executable %s, revision %s, benchmark %s" % (
+                        data['executable'], data['commitid'], data['benchmark']))
                     try:
-                        f = urllib2.urlopen(CODESPEED_URL + 'result/add/', params)
-                    except urllib2.HTTPError, e:
-                        print str(e)
-                        print e.read()
+                        f = urllib.request.urlopen(CODESPEED_URL + 'result/add/', params)
+                    except urllib.error.HTTPError as e:
+                        print(str(e))
+                        print(e.read())
                         return
                     response = f.read()
                     f.close()
-                    print "Server (%s) response: %s\n" % (CODESPEED_URL, response) 
+                    print("Server (%s) response: %s\n" % (CODESPEED_URL, response)) 
  
                 benchmarks = ['Initialization', 'First timestep',\
                                   'Average of remaining timesteps', 'Total Runtime']
@@ -184,11 +189,11 @@ class Efficiency_test(Command):
                         'result_value': results[i],
                         'result_date': datetime.fromtimestamp(revdate)
                         }    
-                    print datetime.fromtimestamp(revdate)
+                    print(datetime.fromtimestamp(revdate))
                     add(data)
             numberOfElements *= self.factor
             f.close()
             os.remove(case)
             os.remove("%s.dat" % case)
-            print "Deleted temporary file ", case
+            print("Deleted temporary file ", case)
             
diff --git a/fipy/tools/performance/memoryLeak.py b/fipy/tools/performance/memoryLeak.py
index 5c7e326..a43c91d 100755
--- a/fipy/tools/performance/memoryLeak.py
+++ b/fipy/tools/performance/memoryLeak.py
@@ -40,6 +40,7 @@ It outputs the top 100 number of outstanding references for each
 object.
 
 """
+from __future__ import print_function
 
 __all__ = []
 
@@ -50,22 +51,22 @@ def _get_refcounts(theClass = None):
     d = {}
     sys.modules
     # collect all classes
-    for m in sys.modules.values():
+    for m in list(sys.modules.values()):
         for sym in dir(m):
             o = getattr (m, sym)
-            if type(o) is types.ClassType:
+            if type(o) is type:
                 if theClass is not None and o is not theClass:
                     continue
                 d[o] = sys.getrefcount (o)
     # sort by refcount
-    pairs = map (lambda x: (x[1],x[0]), d.items())
+    pairs = [(x[1],x[0]) for x in list(d.items())]
     pairs.sort()
     pairs.reverse()
     return pairs
 
 def _print_top_N(n = 100, theClass = None):
     for n, c in _get_refcounts(theClass)[:n]:
-        print '%10d %s' % (n, c.__name__)
+        print('%10d %s' % (n, c.__name__))
 
 if __name__ == '__main__':
     print_top_N()
diff --git a/fipy/tools/performance/memoryLogger.py b/fipy/tools/performance/memoryLogger.py
index b9c8b8a..28d4168 100644
--- a/fipy/tools/performance/memoryLogger.py
+++ b/fipy/tools/performance/memoryLogger.py
@@ -1,3 +1,9 @@
+from __future__ import print_function
+from future import standard_library
+standard_library.install_aliases()
+from builtins import str
+from builtins import range
+from builtins import object
 #!/usr/bin/env python
 
 import os
@@ -37,7 +43,7 @@ class MemoryHighWaterThread(threading.Thread):
         
         return self.maxMem
         
-class MemoryLogger:
+class MemoryLogger(object):
     def __init__(self, sampleTime = 1):
         self.pid = os.getpid()
 
@@ -98,14 +104,14 @@ class MemoryLogger:
 
         
 if __name__ == "__main__":
-    print "MemoryHighWaterThread"
+    print("MemoryHighWaterThread")
     for attempt in range(10):
         thread = MemoryHighWaterThread(pid=os.getpid(), sampleTime=1)
         thread.start()
-        print thread.stop()
+        print(thread.stop())
 
-    print "MemoryLogger"
+    print("MemoryLogger")
     logger = MemoryLogger(sampleTime=1)
     for attempt in range(10):
         logger.start()
-        print logger.stop()
\ No newline at end of file
+        print(logger.stop())
\ No newline at end of file
diff --git a/fipy/tools/vector.py b/fipy/tools/vector.py
index 7745942..128db41 100644
--- a/fipy/tools/vector.py
+++ b/fipy/tools/vector.py
@@ -34,6 +34,8 @@
 
 """Vector utility functions that are inexplicably absent from Numeric
 """
+from builtins import zip
+from builtins import range
 
 from fipy.tools import inline, numerix
 
diff --git a/fipy/tools/vitals.py b/fipy/tools/vitals.py
index 53c1063..ac1a6be 100644
--- a/fipy/tools/vitals.py
+++ b/fipy/tools/vitals.py
@@ -1,3 +1,6 @@
+from __future__ import print_function
+from builtins import zip
+from builtins import str
 import os
 import platform
 import subprocess
@@ -66,7 +69,7 @@ class Vitals(Document):
         
     def dictToXML(self, d, name):
         elem = self.createElement(name)
-        for key, value in d.items():
+        for key, value in list(d.items()):
             keyelem = self.createElement(key)
             keyelem.appendChild(self.createTextNode(str(value)))
             elem.appendChild(keyelem)
@@ -130,4 +133,4 @@ if __name__ == "__main__":
     solar.appendChild(v.svn("/Users/guyer/Documents/research/codes/solar-dimensionless"))
     v.appendChild(solar)
 
-    print v
+    print(v)
diff --git a/fipy/variables/addOverFacesVariable.py b/fipy/variables/addOverFacesVariable.py
index c3da12b..4b53ad0 100644
--- a/fipy/variables/addOverFacesVariable.py
+++ b/fipy/variables/addOverFacesVariable.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __all__ = []
 
 from fipy.tools import numerix
@@ -98,8 +100,8 @@ class _AddOverFacesVariable(CellVariable):
 
         faceContributions = contributions * self.mesh._cellToFaceOrientations[s]
         
-        return numerix.tensordot(numerix.ones(faceContributions.shape[-2], 'd'),
-                                 numerix.MA.filled(faceContributions, 0.), (0, -2)) / self.mesh.cellVolumes
+        return old_div(numerix.tensordot(numerix.ones(faceContributions.shape[-2], 'd'),
+                                 numerix.MA.filled(faceContributions, 0.), (0, -2)), self.mesh.cellVolumes)
 
 
 
diff --git a/fipy/variables/cellVariable.py b/fipy/variables/cellVariable.py
index 0eadca7..5a40e08 100644
--- a/fipy/variables/cellVariable.py
+++ b/fipy/variables/cellVariable.py
@@ -215,7 +215,7 @@ class CellVariable(_MeshVariable):
                                       self.grad.globalValue[...,nearestCellIDs]))
 
             else:
-                raise ValueError, 'order should be either 0 or 1'
+                raise ValueError('order should be either 0 or 1')
 
         else:
             return _MeshVariable.__call__(self)
@@ -494,7 +494,7 @@ class CellVariable(_MeshVariable):
 
         """
         if self._old is None:
-            raise AssertionError, 'The updateOld method requires the CellVariable to have an old value. Set hasOld to True when instantiating the CellVariable.'
+            raise AssertionError('The updateOld method requires the CellVariable to have an old value. Set hasOld to True when instantiating the CellVariable.')
         else:
             self._old.value = self.value.copy()
 
diff --git a/fipy/variables/cellVolumeAverageVariable.py b/fipy/variables/cellVolumeAverageVariable.py
index bd760c1..b92a73d 100755
--- a/fipy/variables/cellVolumeAverageVariable.py
+++ b/fipy/variables/cellVolumeAverageVariable.py
@@ -33,6 +33,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -62,7 +64,7 @@ class _CellVolumeAverageVariable(Variable):
     def _calcValue(self):
         mesh = self.var.mesh
         volumes = CellVariable(mesh=mesh, value=mesh.cellVolumes)
-        return (self.var * volumes).sum() / volumes.sum()
+        return old_div((self.var * volumes).sum(), volumes.sum())
 
 def _test(): 
     import fipy.tests.doctestPlus
diff --git a/fipy/variables/constant.py b/fipy/variables/constant.py
index 16f776c..9193ec3 100644
--- a/fipy/variables/constant.py
+++ b/fipy/variables/constant.py
@@ -1,3 +1,4 @@
+from builtins import str
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/variables/coupledCellVariable.py b/fipy/variables/coupledCellVariable.py
index ff8981f..0b6c59f 100644
--- a/fipy/variables/coupledCellVariable.py
+++ b/fipy/variables/coupledCellVariable.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/variables/distanceVariable.py b/fipy/variables/distanceVariable.py
index 997e5b0..2b402f7 100755
--- a/fipy/variables/distanceVariable.py
+++ b/fipy/variables/distanceVariable.py
@@ -32,6 +32,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.tools import numerix
@@ -293,7 +295,7 @@ class DistanceVariable(CellVariable):
         elif LSM_SOLVER == 'skfmm':
             from skfmm import extension_velocities
         else:
-            raise Exception, "Neither `lsmlib` nor `skfmm` can be found on the $PATH"
+            raise Exception("Neither `lsmlib` nor `skfmm` can be found on the $PATH")
 
         tmp, extensionValue = extension_velocities(phi, extensionValue, ext_mask=phi < 0., dx=dx, order=order)
         extensionVariable[:] = extensionValue.flatten()
@@ -302,7 +304,7 @@ class DistanceVariable(CellVariable):
         mesh = self.mesh
 
         if hasattr(mesh, 'nz'):
-            raise Exception, "3D meshes not yet implemented"
+            raise Exception("3D meshes not yet implemented")
         elif hasattr(mesh, 'ny'):
             dx = (mesh.dy, mesh.dx)
             shape = (mesh.ny, mesh.nx)
@@ -310,7 +312,7 @@ class DistanceVariable(CellVariable):
             dx = (mesh.dx,)
             shape = mesh.shape
         else:
-            raise Exception, "Non grid meshes can not be used for solving the FMM."
+            raise Exception("Non grid meshes can not be used for solving the FMM.")
 
         return dx, shape
 
@@ -331,7 +333,7 @@ class DistanceVariable(CellVariable):
         elif LSM_SOLVER == 'skfmm':
             from skfmm import distance
         else:
-            raise Exception, "Neither `lsmlib` nor `skfmm` can be found on the $PATH"
+            raise Exception("Neither `lsmlib` nor `skfmm` can be found on the $PATH")
 
         self._value = distance(numerix.reshape(self._value, shape), dx=dx, order=order).flatten()
         self._markFresh()
@@ -553,7 +555,7 @@ class DistanceVariable(CellVariable):
         if len(exteriorFaces.value) > 0:
             faceGrad[..., exteriorFaces.value] = 0.
         
-        return faceGrad / faceGradMag 
+        return old_div(faceGrad, faceGradMag) 
 
 def _test(): 
     import fipy.tests.doctestPlus
diff --git a/fipy/variables/faceGradVariable.py b/fipy/variables/faceGradVariable.py
index 5d54675..8e21b42 100644
--- a/fipy/variables/faceGradVariable.py
+++ b/fipy/variables/faceGradVariable.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -155,7 +157,7 @@ class _FaceGradVariable(FaceVariable):
 
         N2[s] = self.var.faceValue[s]
 
-        N = (N2 - numerix.take(self.var,id1, axis=-1)) / dAP
+        N = old_div((N2 - numerix.take(self.var,id1, axis=-1)), dAP)
 
         normals = self.mesh._orientedFaceNormals
 
@@ -172,8 +174,8 @@ class _FaceGradVariable(FaceVariable):
         t2grad1 = numerix.sum(tangents2[s] * grad1, 0)
         t2grad2 = numerix.sum(tangents2[s] * grad2, 0)
 
-        T1 = (t1grad1 + t1grad2) / 2.
-        T2 = (t2grad1 + t2grad2) / 2.
+        T1 = old_div((t1grad1 + t1grad2), 2.)
+        T2 = old_div((t2grad1 + t2grad2), 2.)
 
         return normals[s] * N[numerix.newaxis] + tangents1[s] * T1[numerix.newaxis] + tangents2[s] * T2[numerix.newaxis]
 
diff --git a/fipy/variables/gaussCellGradVariable.py b/fipy/variables/gaussCellGradVariable.py
index 7bad6a8..7bc3982 100644
--- a/fipy/variables/gaussCellGradVariable.py
+++ b/fipy/variables/gaussCellGradVariable.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
  
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -105,7 +107,7 @@ class _GaussCellGradVariable(CellVariable):
     def _calcValueNoInline(self, N, M, ids, orientations, volumes):
         contributions = numerix.take(self.faceGradientContributions, ids, axis=-1)
         grad = numerix.array(numerix.sum(orientations * contributions, -2))
-        return grad / volumes
+        return old_div(grad, volumes)
 
     def _calcValue(self):
         if inline.doInline and self.var.rank == 0:
diff --git a/fipy/variables/leastSquaresCellGradVariable.py b/fipy/variables/leastSquaresCellGradVariable.py
index c420573..fb9a8a2 100644
--- a/fipy/variables/leastSquaresCellGradVariable.py
+++ b/fipy/variables/leastSquaresCellGradVariable.py
@@ -34,6 +34,9 @@
  # ###################################################################
  ##
  
+from __future__ import division
+from builtins import range
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -76,11 +79,11 @@ class _LeastSquaresCellGradVariable(CellVariable):
         vec = numerix.array(numerix.sum((neighborValue - value) * cellDistanceNormals, axis=1))
 
         if D == 1:
-            vec[0] = vec[0] / mat[0, 0]
+            vec[0] = old_div(vec[0], mat[0, 0])
         elif D == 2:
             divisor = mat[0,0] * mat[1,1] - mat[0,1] * mat[1,0]
-            gradx = (vec[0] * mat[1,1] - vec[1] * mat[1,0]) / divisor
-            grady = (vec[1] * mat[0,0] - vec[0] * mat[0,1]) / divisor
+            gradx = old_div((vec[0] * mat[1,1] - vec[1] * mat[1,0]), divisor)
+            grady = old_div((vec[1] * mat[0,0] - vec[0] * mat[0,1]), divisor)
             vec[0] = gradx
             vec[1] = grady
         else:
diff --git a/fipy/variables/meshVariable.py b/fipy/variables/meshVariable.py
index e777f88..6a2fb65 100644
--- a/fipy/variables/meshVariable.py
+++ b/fipy/variables/meshVariable.py
@@ -1,3 +1,5 @@
+from builtins import str
+from functools import reduce
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -66,7 +68,7 @@ class _MeshVariable(Variable):
             if mesh is None:
                 mesh = value.mesh
             elif mesh != value.mesh:
-                raise ValueError, "The new 'Variable' must use the same mesh as the supplied value"
+                raise ValueError("The new 'Variable' must use the same mesh as the supplied value")
 
         self.mesh = mesh
         value = self._globalToLocalValue(value)
@@ -78,13 +80,13 @@ class _MeshVariable(Variable):
             unit = None
             if isinstance(value, _MeshVariable):
                 if not isinstance(value, self._variableClass):
-                    raise TypeError, "A '%s' cannot be cast to a '%s'" % (value._variableClass.__name__, 
-                                                                          self._variableClass.__name__)
+                    raise TypeError("A '%s' cannot be cast to a '%s'" % (value._variableClass.__name__, 
+                                                                          self._variableClass.__name__))
                 if elementshape is not None and elementshape != value.shape[:-1]:
-                    raise ValueError, "'elementshape' != shape of elements of 'value'"
+                    raise ValueError("'elementshape' != shape of elements of 'value'")
 
                 if rank is not None and rank != value.rank:
-                    raise ValueError, "'rank' != rank of 'value'"
+                    raise ValueError("'rank' != rank of 'value'")
 
                 elementshape = value.shape[:-1]
                 array = None
@@ -95,10 +97,10 @@ class _MeshVariable(Variable):
             valueShape = numerix.getShape(value)
             if valueShape != () and valueShape[-1] == self._getShapeFromMesh(mesh)[-1]:
                 if elementshape is not None and elementshape != valueShape[:-1]:
-                    raise ValueError, "'elementshape' != shape of elements of 'value'"
+                    raise ValueError("'elementshape' != shape of elements of 'value'")
 
                 if rank is not None and rank != len(valueShape[:-1]):
-                    raise ValueError, "'rank' != rank of 'value'"
+                    raise ValueError("'rank' != rank of 'value'")
                 elementshape = valueShape[:-1]
             elif rank is None and elementshape is None:
                 elementshape = valueShape
@@ -109,7 +111,7 @@ class _MeshVariable(Variable):
         elif elementshape is None:
             elementshape = rank * (mesh.dim,)
         elif len(elementshape) != rank:
-            raise ValueError, 'len(elementshape) != rank'
+            raise ValueError('len(elementshape) != rank')
                 
         self.elementshape = elementshape
         
diff --git a/fipy/variables/modCellGradVariable.py b/fipy/variables/modCellGradVariable.py
index ed2740c..d0eaa62 100644
--- a/fipy/variables/modCellGradVariable.py
+++ b/fipy/variables/modCellGradVariable.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
  
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -79,5 +81,5 @@ class _ModCellGradVariable(_GaussCellGradVariable):
     def _calcValueNoInline(self, N, M, ids, orientations, volumes):
         value = _GaussCellGradVariable._calcValueNoInline(self, N, M, ids, orientations, volumes)
         gridSpacing = self.mesh._meshSpacing
-        return self.modPy(value * gridSpacing) / gridSpacing
+        return old_div(self.modPy(value * gridSpacing), gridSpacing)
 
diff --git a/fipy/variables/modFaceGradVariable.py b/fipy/variables/modFaceGradVariable.py
index 247515b..e90ce6e 100644
--- a/fipy/variables/modFaceGradVariable.py
+++ b/fipy/variables/modFaceGradVariable.py
@@ -34,6 +34,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -92,7 +94,7 @@ class _ModFaceGradVariable(_FaceGradVariable):
         def _calcValue(self):
             dAP = self.mesh._cellDistances
             id1, id2 = self.mesh._adjacentCellIDs
-            N = (numerix.take(self.var,id2) - numerix.take(self.var,id1)) / dAP
+            N = old_div((numerix.take(self.var,id2) - numerix.take(self.var,id1)), dAP)
             normals = self.mesh._orientedFaceNormals
             
             tangents1 = self.mesh._faceTangents1
@@ -106,7 +108,7 @@ class _ModFaceGradVariable(_FaceGradVariable):
             t2grad1 = numerix.sum(tangents2*grad1,0)
             t2grad2 = numerix.sum(tangents2*grad2,0)
             
-            T1 = (t1grad1 + t1grad2) / 2.
-            T2 = (t2grad1 + t2grad2) / 2.
+            T1 = old_div((t1grad1 + t1grad2), 2.)
+            T2 = old_div((t2grad1 + t2grad2), 2.)
             
             return normals * N + tangents1 * T1 + tangents2 * T2
diff --git a/fipy/variables/noiseVariable.py b/fipy/variables/noiseVariable.py
index db0104d..939ba9b 100644
--- a/fipy/variables/noiseVariable.py
+++ b/fipy/variables/noiseVariable.py
@@ -54,7 +54,7 @@ class NoiseVariable(CellVariable):
     """
     def __init__(self, mesh, name = '', hasOld = 0):
         if self.__class__ is NoiseVariable:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         CellVariable.__init__(self, mesh = mesh, name = name, hasOld = hasOld)
         self.scramble()
diff --git a/fipy/variables/operatorVariable.py b/fipy/variables/operatorVariable.py
index c591727..22dd0c3 100644
--- a/fipy/variables/operatorVariable.py
+++ b/fipy/variables/operatorVariable.py
@@ -1,3 +1,5 @@
+from builtins import str
+from builtins import range
 ## -*-Pyth-*-
  # #############################################################################
  # FiPy - a finite volume PDE solver in Python
@@ -62,10 +64,10 @@ def _OperatorVariableClass(baseClass=object):
             self.comment = inlineComment
 
         def __setitem__(self, index, value):
-            raise TypeError, "The value of an `_OperatorVariable` cannot be assigned"
+            raise TypeError("The value of an `_OperatorVariable` cannot be assigned")
             
         def setValue(self, value, unit=None, where=None):
-            raise TypeError, "The value of an `_OperatorVariable` cannot be assigned"
+            raise TypeError("The value of an `_OperatorVariable` cannot be assigned")
         
         def _calcValue(self):
             if not self.canInline:
@@ -125,7 +127,7 @@ def _OperatorVariableClass(baseClass=object):
                         result = "<...>"
 
                 elif style == "TeX":
-                    raise Exception, "TeX style not yet implemented"
+                    raise Exception("TeX style not yet implemented")
                 elif style == "C":
                     if not v._isCached():
                         result = v._getCstring(argDict, id=id + str(i), freshen=freshen)
@@ -138,7 +140,7 @@ def _OperatorVariableClass(baseClass=object):
                                                                    id=id + str(i),
                                                                    freshen=False)
                 else:
-                    raise SyntaxError, "Unknown style: %s" % style
+                    raise SyntaxError("Unknown style: %s" % style)
                     
                 return result
 
@@ -146,7 +148,7 @@ def _OperatorVariableClass(baseClass=object):
                 return "%s(%s)" % (self.op.__name__, ", ".join([__var(i) for i in range(len(self.var))]))
             
             if sys.version_info < (3,0):
-                bytecodes = [ord(byte) for byte in self.op.func_code.co_code]
+                bytecodes = [ord(byte) for byte in self.op.__code__.co_code]
             else:
                 bytecodes = list(self.op.__code__.co_code)
                 
@@ -177,14 +179,14 @@ def _OperatorVariableClass(baseClass=object):
                     else:
                         return s
                 elif opcode.opname[bytecode] == 'LOAD_CONST':
-                    stack.append(self.op.func_code.co_consts[_popIndex()])
+                    stack.append(self.op.__code__.co_consts[_popIndex()])
                 elif opcode.opname[bytecode] == 'LOAD_ATTR':
-                    stack.append(stack.pop() + "." + self.op.func_code.co_names[_popIndex()])
+                    stack.append(stack.pop() + "." + self.op.__code__.co_names[_popIndex()])
                 elif opcode.opname[bytecode] == 'COMPARE_OP':
                     stack.append(stack.pop(-2) + " " + opcode.cmp_op[_popIndex()] + " " + stack.pop())
                 elif opcode.opname[bytecode] == 'LOAD_GLOBAL':
                     counter = _popIndex()
-                    stack.append(self.op.func_code.co_names[counter])
+                    stack.append(self.op.__code__.co_names[counter])
                 elif opcode.opname[bytecode] == 'LOAD_FAST':
                     stack.append(__var(_popIndex()))
                 elif opcode.opname[bytecode] == 'CALL_FUNCTION':    
@@ -197,17 +199,17 @@ def _OperatorVariableClass(baseClass=object):
                         args.insert(0, stack.pop())
                     stack.append(stack.pop() + "(" + ", ".join(args) + ")")
                 elif opcode.opname[bytecode] == 'LOAD_DEREF':
-                    free = self.op.func_code.co_cellvars + self.op.func_code.co_freevars
+                    free = self.op.__code__.co_cellvars + self.op.__code__.co_freevars
                     stack.append(free[_popIndex()])
                 elif bytecode in unop:
                     stack.append(unop[bytecode] + '(' + stack.pop() + ')')
                 elif bytecode in binop:
                     stack.append(stack.pop(-2) + " " + binop[bytecode] + " " + stack.pop())
                 else:
-                    raise SyntaxError, "Unknown bytecode: %s in %s: %s" % (
+                    raise SyntaxError("Unknown bytecode: %s in %s: %s" % (
                        repr(bytecode), 
-                       repr([ord(byte) for byte in self.op.func_code.co_code]),
-                       "FIXME")
+                       repr([ord(byte) for byte in self.op.__code__.co_code]),
+                       "FIXME"))
                 
         def __repr__(self):
             return self._getRepresentation()
@@ -217,7 +219,7 @@ def _OperatorVariableClass(baseClass=object):
             Allows _OperatorVariables to be pickled
             """
             state =  self.__getstate__()
-            if 'mesh' in state.keys():
+            if 'mesh' in list(state.keys()):
                 args = (state['mesh'],)
             else:
                 args = ()
diff --git a/fipy/variables/scharfetterGummelFaceVariable.py b/fipy/variables/scharfetterGummelFaceVariable.py
index bd1e21c..b98890b 100644
--- a/fipy/variables/scharfetterGummelFaceVariable.py
+++ b/fipy/variables/scharfetterGummelFaceVariable.py
@@ -1,3 +1,5 @@
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 from fipy.variables.cellToFaceVariable import _CellToFaceVariable
@@ -16,10 +18,10 @@ class ScharfetterGummelFaceVariable(_CellToFaceVariable):
         delta = cell1 - cell2
         
         eps = 1e-14
-        value = where(abs(delta) < eps, 1. / exp(delta), 0.)
+        value = where(abs(delta) < eps, old_div(1., exp(delta)), 0.)
         delta = where(abs(delta) < eps, eps, delta) 
         value = where((abs(delta) > eps) & (delta < 100), 
-                      delta / (exp(delta) - 1), value)
+                      old_div(delta, (exp(delta) - 1)), value)
                             
         value *= exp(cell1) 
         
diff --git a/fipy/variables/surfactantConvectionVariable.py b/fipy/variables/surfactantConvectionVariable.py
index 60ba7ce..3fa6d8d 100755
--- a/fipy/variables/surfactantConvectionVariable.py
+++ b/fipy/variables/surfactantConvectionVariable.py
@@ -33,6 +33,8 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 __all__ = ['SurfactantConvectionVariable']
@@ -125,7 +127,7 @@ class SurfactantConvectionVariable(FaceVariable):
 
         alphasum = numerix.sum(alpha, axis=0)
         alphasum += (alphasum < 1e-100) * 1.0
-        alpha = alpha / alphasum
+        alpha = old_div(alpha, alphasum)
 
         phi = numerix.repeat(self.distanceVar[numerix.newaxis, ...], M, axis=0)
         alpha = numerix.where(phi > 0., 0, alpha)
@@ -139,7 +141,7 @@ class SurfactantConvectionVariable(FaceVariable):
 
 ##         value = numerix.reshape(value, (dim, Nfaces, dim))
 
-        return -value / self.mesh._faceAreas
+        return old_div(-value, self.mesh._faceAreas)
 
 def _test(): 
     import fipy.tests.doctestPlus
diff --git a/fipy/variables/variable.py b/fipy/variables/variable.py
index f228cce..b8c7f82 100644
--- a/fipy/variables/variable.py
+++ b/fipy/variables/variable.py
@@ -32,6 +32,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from builtins import str
+from builtins import object
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -921,7 +925,7 @@ class Variable(object):
                     dim = (nk,nj,ni)
                     argDict['nk'] = nk
                 else:
-                    raise DimensionError, 'Impossible Dimensions'
+                    raise DimensionError('Impossible Dimensions')
 
         ## Following section makes sure that the result array has a
         ## valid typecode. If self._value is None then a typecode is
@@ -1116,12 +1120,12 @@ class Variable(object):
         return self._BinaryOperatorVariable(lambda a,b: pow(b,a), other)
             
     def __truediv__(self, other):
-        return self._BinaryOperatorVariable(lambda a,b: a/b, other)
+        return self._BinaryOperatorVariable(lambda a,b: old_div(a,b), other)
         
     __div__ = __truediv__
     
     def __rtruediv__(self, other):
-        return self._BinaryOperatorVariable(lambda a,b: b/a, other)
+        return self._BinaryOperatorVariable(lambda a,b: old_div(b,a), other)
             
     __rdiv__ = __rtruediv__
     
@@ -1317,7 +1321,7 @@ class Variable(object):
     def __int__(self):
         return int(self.value)
         
-    def __nonzero__(self):
+    def __bool__(self):
         """
             >>> print bool(Variable(value=0))
             0
diff --git a/fipy/viewers/__init__.py b/fipy/viewers/__init__.py
index 82b495c..06953d4 100644
--- a/fipy/viewers/__init__.py
+++ b/fipy/viewers/__init__.py
@@ -1,3 +1,4 @@
+from builtins import str
 __docformat__ = 'restructuredtext'
 
 __all__ = []
@@ -111,17 +112,17 @@ def Viewer(vars, title=None, limits={}, FIPY_VIEWER=None, **kwlimits):
                 viewers.append(viewer)
                 
             break
-        except Exception, s:
+        except Exception as s:
             errors.append("%s: %s" % (ep.name, s))
 
     if len(attempts) == 0:
         if FIPY_VIEWER is not None:
-            raise ImportError, "`%s` viewer not found" % FIPY_VIEWER
+            raise ImportError("`%s` viewer not found" % FIPY_VIEWER)
         else:
-            raise ImportError, "No viewers found. Run `python setup.py egg_info` or similar."
+            raise ImportError("No viewers found. Run `python setup.py egg_info` or similar.")
     
     if len(vars) > 0:
-        raise ImportError, "Failed to import a viewer: %s" % str(errors)
+        raise ImportError("Failed to import a viewer: %s" % str(errors))
             
     if len(viewers) > 1:
         return MultiViewer(viewers = viewers)
diff --git a/fipy/viewers/matplotlibViewer/matplotlib1DViewer.py b/fipy/viewers/matplotlibViewer/matplotlib1DViewer.py
index f39482f..3a60254 100644
--- a/fipy/viewers/matplotlibViewer/matplotlib1DViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlib1DViewer.py
@@ -1,3 +1,4 @@
+from builtins import zip
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -130,7 +131,7 @@ class Matplotlib1DViewer(AbstractMatplotlibViewer):
             vars = [var for var in vars if var.mesh is vars[0].mesh]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "Can only plot 1D data"
+            raise MeshDimensionError("Can only plot 1D data")
         return vars
 
     def _plot(self):
diff --git a/fipy/viewers/matplotlibViewer/matplotlib2DContourViewer.py b/fipy/viewers/matplotlibViewer/matplotlib2DContourViewer.py
index aa86c7c..6906f7f 100644
--- a/fipy/viewers/matplotlibViewer/matplotlib2DContourViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlib2DContourViewer.py
@@ -102,7 +102,7 @@ class Matplotlib2DContourViewer(AbstractMatplotlib2DViewer):
               and var.rank == 0)]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "Matplotlib2DViewer can only display a rank-0, 2D CellVariable"
+            raise MeshDimensionError("Matplotlib2DViewer can only display a rank-0, 2D CellVariable")
         # this viewer can only display one variable
         return [vars[0]]
         
@@ -132,7 +132,7 @@ class Matplotlib2DContourViewer(AbstractMatplotlib2DViewer):
             for collection in self._contourSet.collections:
                 try:
                     ix = self.axes.collections.index(collection)
-                except ValueError, e:
+                except ValueError as e:
                     ix = None
                     
                 if ix is not None:
diff --git a/fipy/viewers/matplotlibViewer/matplotlib2DGridContourViewer.py b/fipy/viewers/matplotlibViewer/matplotlib2DGridContourViewer.py
index 58be6a0..0c3f96a 100644
--- a/fipy/viewers/matplotlibViewer/matplotlib2DGridContourViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlib2DGridContourViewer.py
@@ -94,7 +94,7 @@ class Matplotlib2DGridContourViewer(AbstractMatplotlib2DViewer):
               and isinstance(var, CellVariable))]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "The mesh must be a Grid2D instance"
+            raise MeshDimensionError("The mesh must be a Grid2D instance")
         # this viewer can only display one variable
         return [vars[0]]
         
diff --git a/fipy/viewers/matplotlibViewer/matplotlib2DGridViewer.py b/fipy/viewers/matplotlibViewer/matplotlib2DGridViewer.py
index f98895b..12bdcdc 100644
--- a/fipy/viewers/matplotlibViewer/matplotlib2DGridViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlib2DGridViewer.py
@@ -118,7 +118,7 @@ class Matplotlib2DGridViewer(AbstractMatplotlib2DViewer):
               and var.rank == 0)]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "Matplotlib2DGridViewer can only display a rank-0 CellVariable with a UniformGrid2D mesh"
+            raise MeshDimensionError("Matplotlib2DGridViewer can only display a rank-0 CellVariable with a UniformGrid2D mesh")
         # this viewer can only display one variable
         return [vars[0]]
         
diff --git a/fipy/viewers/matplotlibViewer/matplotlib2DViewer.py b/fipy/viewers/matplotlibViewer/matplotlib2DViewer.py
index 4ca5dc6..4faeea9 100644
--- a/fipy/viewers/matplotlibViewer/matplotlib2DViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlib2DViewer.py
@@ -1,3 +1,4 @@
+from builtins import zip
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -105,7 +106,7 @@ class Matplotlib2DViewer(AbstractMatplotlib2DViewer):
                 x = x.compressed()
             if hasattr(y, 'mask'):
                 y = y.compressed()
-            polys.append(zip(x,y))
+            polys.append(list(zip(x,y)))
 
         from matplotlib.collections import PolyCollection
         self.collection = PolyCollection(polys)
@@ -134,7 +135,7 @@ class Matplotlib2DViewer(AbstractMatplotlib2DViewer):
               and var.rank == 0)]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "Matplotlib2DViewer can only display a rank-0, 2D CellVariable"
+            raise MeshDimensionError("Matplotlib2DViewer can only display a rank-0, 2D CellVariable")
         # this viewer can only display one variable
         return [vars[0]]
         
diff --git a/fipy/viewers/matplotlibViewer/matplotlibSparseMatrixViewer.py b/fipy/viewers/matplotlibViewer/matplotlibSparseMatrixViewer.py
index 2142470..13d6d2c 100644
--- a/fipy/viewers/matplotlibViewer/matplotlibSparseMatrixViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlibSparseMatrixViewer.py
@@ -1,3 +1,8 @@
+from __future__ import division
+from __future__ import print_function
+from builtins import zip
+from builtins import object
+from past.utils import old_div
 ## -*-Pyth-*-
  # #############################################################################
  # FiPy - a finite volume PDE solver in Python
@@ -83,7 +88,7 @@ class SignedLogFormatter(ticker.LogFormatter):
         #int
         if abs(x)<1e4 and x==int(x): return '%+d' % x
 
-        d = 10**(d / 2.)
+        d = 10**(old_div(d, 2.))
         
         if d < 1e-2: fmt = '%+1.3e'
         elif d < 1e-1: fmt = '%+1.3f'
@@ -145,14 +150,14 @@ class SignedLogLocator(ticker.LogLocator):
                     subs = numerix.arange(2.0, b, 2.0)
                 else: 
                     subs = numerix.arange(2.0, b)
-                subs = numerix.log(subs) / numerix.log(b)
+                subs = old_div(numerix.log(subs), numerix.log(b))
             else:
                 subs = self._subs
                 if numdec == 0 and len(subs) == 1:
-                    subs = numerix.array(list(subs) + list(numerix.log(numerix.arange(2.0, b)) / numerix.log(b)))
+                    subs = numerix.array(list(subs) + list(old_div(numerix.log(numerix.arange(2.0, b)), numerix.log(b))))
 
             stride = 1
-            while numdec/stride+1 > self.numticks:
+            while old_div(numdec,stride)+1 > self.numticks:
                 stride += 1
 
             for decadeStart in numerix.arange(numerix.floor(self.threshold), 
@@ -184,19 +189,19 @@ class SignedLogLocator(ticker.LogLocator):
         if remainder < 0.5:
             exponent -= 1
         scale = 10**(-exponent)
-        vmin = numerix.floor(scale*vmin)/scale
-        vmax = numerix.ceil(scale*vmax)/scale
+        vmin = old_div(numerix.floor(scale*vmin),scale)
+        vmax = old_div(numerix.ceil(scale*vmax),scale)
 
         return nonsingular(vmin, vmax)
                    
-class MatplotlibSparseMatrixViewer:
+class MatplotlibSparseMatrixViewer(object):
     def __init__(self, title="Sparsity"):
         self.title = title
         
         self.L_width = 0.8
-        self.margin = (1. - self.L_width) / 2
+        self.margin = old_div((1. - self.L_width), 2)
         self.b_width = self.margin
-        self.c_width = self.margin / 3
+        self.c_width = old_div(self.margin, 3)
         self.buffer = 1.5 * self.margin
         self.aspect = (self.margin + self.L_width                   # M
                        + self.buffer + self.c_width                 # colorbar
@@ -204,7 +209,7 @@ class MatplotlibSparseMatrixViewer:
 
         pyplot.ion()
         
-        fig = pyplot.figure(figsize=pyplot.figaspect(1. / self.aspect))
+        fig = pyplot.figure(figsize=pyplot.figaspect(old_div(1., self.aspect)))
         self.id = fig.number
         
     def plot(self, matrix, RHSvector, log='auto'):
@@ -212,12 +217,12 @@ class MatplotlibSparseMatrixViewer:
         import os
         
         if "print" in os.environ['FIPY_DISPLAY_MATRIX'].lower().split():
-            print "-"*75
-            print self.title
-            print "-"*75
-            print "L:"
-            print matrix
-            print "b:", RHSvector
+            print("-"*75)
+            print(self.title)
+            print("-"*75)
+            print("L:")
+            print(matrix)
+            print("b:", RHSvector)
         
         (f, mtxName) = tempfile.mkstemp(suffix='.mtx')
         matrix.exportMmf(mtxName)
@@ -308,15 +313,15 @@ class MatplotlibSparseMatrixViewer:
         norm = Normalize(vmin=-zRange, vmax=zRange)
         
         x0 = self.margin
-        L_ax = fig.add_axes([x0 / self.aspect, self.margin, self.L_width / self.aspect, self.L_width])
+        L_ax = fig.add_axes([old_div(x0, self.aspect), self.margin, old_div(self.L_width, self.aspect), self.L_width])
         L_ax.text(0.5, -0.1, "L", 
                   transform=L_ax.transAxes, horizontalalignment='center', verticalalignment='baseline')
 
         x0 += self.L_width + self.buffer
-        c_ax = fig.add_axes([x0 / self.aspect, self.margin, self.c_width / self.aspect, self.L_width])
+        c_ax = fig.add_axes([old_div(x0, self.aspect), self.margin, old_div(self.c_width, self.aspect), self.L_width])
 
         x0 += self.c_width + self.buffer
-        b_ax = fig.add_axes([x0 / self.aspect, self.margin, self.b_width / self.aspect, self.L_width],
+        b_ax = fig.add_axes([old_div(x0, self.aspect), self.margin, old_div(self.b_width, self.aspect), self.L_width],
                             sharey=L_ax)
         b_ax.text(0.5, -0.1, "b", 
                   transform=b_ax.transAxes, horizontalalignment='center', verticalalignment='baseline')
diff --git a/fipy/viewers/matplotlibViewer/matplotlibStreamViewer.py b/fipy/viewers/matplotlibViewer/matplotlibStreamViewer.py
index 7fb004b..3ee7ccd 100644
--- a/fipy/viewers/matplotlibViewer/matplotlibStreamViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlibStreamViewer.py
@@ -137,7 +137,7 @@ class MatplotlibStreamViewer(AbstractMatplotlib2DViewer):
                          or isinstance(var, CellVariable)) and var.rank == 1)]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "The mesh must be a Mesh2D instance"
+            raise MeshDimensionError("The mesh must be a Mesh2D instance")
         # this viewer can only display one variable
         return [vars[0]]
                 
diff --git a/fipy/viewers/matplotlibViewer/matplotlibVectorViewer.py b/fipy/viewers/matplotlibViewer/matplotlibVectorViewer.py
index afbadaa..358942e 100644
--- a/fipy/viewers/matplotlibViewer/matplotlibVectorViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlibVectorViewer.py
@@ -140,7 +140,7 @@ class MatplotlibVectorViewer(AbstractMatplotlib2DViewer):
                          or isinstance(var, CellVariable)) and var.rank == 1)]
         if len(vars) == 0:
             from fipy.viewers import MeshDimensionError
-            raise MeshDimensionError, "The mesh must be a Mesh2D instance"
+            raise MeshDimensionError("The mesh must be a Mesh2D instance")
         # this viewer can only display one variable
         return [vars[0]]
                 
diff --git a/fipy/viewers/matplotlibViewer/matplotlibViewer.py b/fipy/viewers/matplotlibViewer/matplotlibViewer.py
index f57fe26..950575d 100644
--- a/fipy/viewers/matplotlibViewer/matplotlibViewer.py
+++ b/fipy/viewers/matplotlibViewer/matplotlibViewer.py
@@ -1,3 +1,4 @@
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -78,7 +79,7 @@ class AbstractMatplotlibViewer(AbstractViewer):
             whether to logarithmically scale the data
         """
         if self.__class__ is AbstractMatplotlibViewer:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         AbstractViewer.__init__(self, vars=vars, title=title, **kwlimits)
 
diff --git a/fipy/viewers/mayaviViewer/mayaviClient.py b/fipy/viewers/mayaviViewer/mayaviClient.py
index 334088e..a33bf89 100755
--- a/fipy/viewers/mayaviViewer/mayaviClient.py
+++ b/fipy/viewers/mayaviViewer/mayaviClient.py
@@ -35,6 +35,10 @@
  # ###################################################################
  ##
 
+from __future__ import division
+from __future__ import print_function
+from builtins import str
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 import os
@@ -178,11 +182,11 @@ class MayaviClient(AbstractViewer):
                 lock.close()
                 plotted = True
                 
-            if (time.time() - start > 30. / self.fps) and not plotted:
-                print "viewer: NOT READY"
+            if (time.time() - start > old_div(30., self.fps)) and not plotted:
+                print("viewer: NOT READY")
                 start = time.time()
         if not plotted:
-            print "viewer: SKIPPED"
+            print("viewer: SKIPPED")
     
     def _validFileExtensions(self):
         return [".png",".jpg",".bmp",".tiff",".ps",".eps",".pdf",".rib",".oogl",".iv",".vrml",".obj"]
diff --git a/fipy/viewers/mayaviViewer/mayaviDaemon.py b/fipy/viewers/mayaviViewer/mayaviDaemon.py
index 8f0cfc8..92f1100 100644
--- a/fipy/viewers/mayaviViewer/mayaviDaemon.py
+++ b/fipy/viewers/mayaviViewer/mayaviDaemon.py
@@ -62,6 +62,8 @@ Run::
  
 to see available options.
 """
+from __future__ import division
+from past.utils import old_div
 __docformat__ = 'restructuredtext'
 
 # Standard imports.
@@ -75,7 +77,7 @@ try:
     from mayavi.sources.vtk_file_reader import VTKFileReader
     from pyface.timer.api import Timer
     from mayavi import mlab
-except ImportError, e:
+except ImportError as e:
     from enthought.mayavi.plugins.app import Mayavi
     from enthought.mayavi.sources.vtk_file_reader import VTKFileReader
     from enthought.pyface.timer.api import Timer
@@ -213,7 +215,7 @@ class MayaviDaemon(Mayavi):
         self.view_data()
 
         # Poll the lock file.
-        self.timer = Timer(1000 / self.fps, self.poll_file)
+        self.timer = Timer(old_div(1000, self.fps), self.poll_file)
 
     def __del__(self):
         dir = None
diff --git a/fipy/viewers/tsvViewer.py b/fipy/viewers/tsvViewer.py
index 9d9fb0e..04e5c67 100755
--- a/fipy/viewers/tsvViewer.py
+++ b/fipy/viewers/tsvViewer.py
@@ -1,3 +1,4 @@
+from builtins import range
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
diff --git a/fipy/viewers/viewer.py b/fipy/viewers/viewer.py
index 48a128b..a4dc09a 100644
--- a/fipy/viewers/viewer.py
+++ b/fipy/viewers/viewer.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import object
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -59,7 +61,7 @@ class AbstractViewer(object):
             (default) value of `None` will autoscale.
         """
         if self.__class__ is AbstractViewer:
-            raise NotImplementedError, "can't instantiate abstract base class"
+            raise NotImplementedError("can't instantiate abstract base class")
             
         self.vars = self._getSuitableVars(vars)
 
@@ -201,7 +203,7 @@ class AbstractViewer(object):
                 extensions = " (%s)" % extensions
             snapshot = self._doctest_raw_input("Enter a filename%s to save a snapshot (leave blank to skip): " % extensions).strip()
             self.plot(snapshot)
-            print opinion
+            print(opinion)
               
         
     def _test1D(**kwargs):
diff --git a/fipy/viewers/vtkViewer/vtkViewer.py b/fipy/viewers/vtkViewer/vtkViewer.py
index fc415ff..9dbb861 100644
--- a/fipy/viewers/vtkViewer/vtkViewer.py
+++ b/fipy/viewers/vtkViewer/vtkViewer.py
@@ -48,7 +48,7 @@ def _checkForTVTK():
     try:
         try:
             from tvtk.api import tvtk
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.api import tvtk
     except Exception:
         hasTVTK = False
@@ -121,7 +121,7 @@ class VTKViewer(AbstractViewer):
 
         try:
             from tvtk.misc import write_data
-        except ImportError, e:
+        except ImportError as e:
             from enthought.tvtk.misc import write_data
         write_data(self.dataset, filename)
         
diff --git a/setup.py b/setup.py
index 8f1294d..2162297 100644
--- a/setup.py
+++ b/setup.py
@@ -1,3 +1,5 @@
+from __future__ import print_function
+from builtins import str
 #!/usr/bin/env python
 
 ## -*-Pyth-*-
@@ -58,7 +60,7 @@ try:
     # (and we're running as a bitten.slave)
     from bitten.util.testrunner import unittest as _unittest
     unittest = _TestClass(_unittest)
-except ImportError, e:
+except ImportError as e:
     unittest = test
 
 
@@ -155,54 +157,54 @@ class upload_products(Command):
 
     def run(self):
         if self.pdf:
-            print "setting permissions of manual..."
+            print("setting permissions of manual...")
             os.system('chmod -R g+w documentation/_build/latex/fipy.pdf')
             
-            print "linking manual to `dist/`..."
+            print("linking manual to `dist/`...")
             os.system('mkdir dist/')
             os.system('ln -f documentation/_build/latex/fipy.pdf dist/fipy-%s.pdf'%self.distribution.metadata.get_version())
             
         if self.html:
-            print "setting group and ownership of web pages..."
+            print("setting group and ownership of web pages...")
             os.system('chmod -R g+w documentation/_build/html/')
             
-            print "uploading web pages..."
+            print("uploading web pages...")
             # The -t flag (implicit in -a) is suddenly causing problems
             # os.system('rsync -aLC -e ssh %s %s'%('documentation/www/', os.environ['FIPY_WWWHOST']))
             os.system('rsync -rlpgoDLC -e ssh %s %s' % ('documentation/_build/html/', os.environ['FIPY_WWWHOST']))
 
         if self.tarball:
             file = 'dist/FiPy-%s.tar.gz' % self.distribution.metadata.get_version()
-            print "setting permissions for %s ..." % file
+            print("setting permissions for %s ..." % file)
             os.system('chmod -R g+w %s' % file)
 
-            print "uploading tarball..."
+            print("uploading tarball...")
             os.system('rsync -pgoDLC -e ssh %s %s/download/' % (file, os.environ['FIPY_WWWHOST']))
 
         if self.winzip:
             file = 'dist/FiPy-%s.win32.zip' % self.distribution.metadata.get_version()
-            print "setting permissions for %s ..." % file
+            print("setting permissions for %s ..." % file)
             os.system('chmod -R g+w %s' % file)
             
-            print "uploading winzip..."
+            print("uploading winzip...")
             os.system('rsync -pgoDLC -e ssh %s %s/download/' % (file, os.environ['FIPY_WWWHOST']))
 
         if self.pdf or self.tarball or self.winzip:
-            print "activating web pages..."
+            print("activating web pages...")
             os.system(os.environ['FIPY_WWWACTIVATE'])
 
 try:            
     f = open('README.rst', 'r')
     long_description = '\n' + f.read() + '\n'
     f.close()
-except IOError, e:
+except IOError as e:
     long_description = ''
         
 try:
     f = open('LICENSE.rst', 'r') 
     license = '\n' + ''.join([' '*8 + l for l in f])
     f.close()
-except IOError, e:
+except IOError as e:
     license = ''    
 # The following doesn't work reliably, because it requires fipy
 # to already be installed (or at least egged), which is kind of 
@@ -295,23 +297,23 @@ if 'install' in dist.commands:
     for pkg in ['numpy', 'pysparse']:
         try:
             __import__(pkg)
-        except ImportError, exc:
+        except ImportError as exc:
             req.append(pkg)
             
     if len(req) > 0:
-        print "!!!!!!"
-        print "The required module(s) " + str(req) + " cannot be loaded."
-        print "FiPy will not work properly until these modules are installed."
+        print("!!!!!!")
+        print("The required module(s) " + str(req) + " cannot be loaded.")
+        print("FiPy will not work properly until these modules are installed.")
 
     opt = []
     
     for pkg in ['scipy', 'matplotlib', 'mayavi']:
         try:
             __import__(pkg)
-        except ImportError, exc:
+        except ImportError as exc:
             opt.append(pkg)
         
     if len(opt) > 0:
-        print "------"
-        print "The optional module(s) " + str(opt) + " cannot be loaded."
-        print "FiPy will have improved capabilities if these modules are installed."
+        print("------")
+        print("The optional module(s) " + str(opt) + " cannot be loaded.")
+        print("FiPy will have improved capabilities if these modules are installed.")
